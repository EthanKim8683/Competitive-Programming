# Practice Problems Status
Problem|Rating|Correct cases|Attempts|Notes
-|-|-|-|-
189A|1300|AC|1|N/A
476B|1300|AC|5|N/A
1285B|1300|AC|5|N/A
1360E|1300|AC|1|N/A
1470A|1300|AC|2|N/A
1555C|1300|AC|1|N/A
455A|1500|AC|3|N/A
550C|1500|AC|1|N/A
550A|1500|AC|1|N/A
466C|1700|AC|2|N/A
474D|1700|AC|2|N/A
1459B|1300|AC|3|N/A
1272D|1500|AC|2|N/A
431C|1600|AC|2|N/A
1389C|1500|AC|1|N/A
1091D|1700|AC|1|N/A
1061C|1700|AC|2|N/A
1015E1|1700|AC|1|N/A
977F|1700|AC|2|N/A
118D|1700|AC|1|N/A
467C|1700|AC|3|N/A
166E|1500|AC|2|N/A
1526C1|1500|AC|1|N/A
5C|1900|AC|1|N/A
577B|1900|AC|2|N/A
1369D|1900|AC|1|N/A
1092F|1900|AC|1|N/A
1114D|1900|AC|2|N/A
547B|1900|AC|1|N/A
1036C|1900|AC|1|N/A
1627D|1900|AC|1|N/A
552C|1900|AC|1|N/A
545C|1500|AC|1|N/A
996A|800|AC|1|N/A
489C|1400|AC|2|N/A
626B|1300|AC|1|N/A
234C|1300|AC|1|N/A
653B|1300|AC|1|N/A
698A|1400|AC|2|N/A
1526B|1400|AC|2|N/A
1195C|1400|AC|2|N/A
1350B|1400|AC|2|N/A
414B|1400|AC|1|N/A
1380C|1400|AC|2|N/A
538B|1400|AC|1|N/A
1245C|1400|AC|1|N/A
1320A|1400|AC|2|N/A
1472B|800|AC|1|N/A
702A|800|AC|1|N/A
1538A|800|AC|1|N/A
894A|800|AC|1|N/A
1519B|800|AC|1|N/A
1462B|800|AC|1|N/A
1466B|800|AC|1|N/A
1180A|800|AC|1|N/A
1539B|800|AC|1|N/A
1598A|800|AC|1|N/A
1323A|800|AC|1|N/A
1566B|800|AC|1|N/A
1686B|800|AC|1|N/A
910A|800|AC|1|N/A
580A|800|AC|1|N/A
1475B|800|AC|2|N/A
1339A|900|AC|1|N/A
1206B|900|AC|1|N/A
1593B|900|AC|1|N/A
1559B|900|AC|1|N/A
1709B|900|AC|1|N/A
1451B|900|AC|2|N/A
1501B|900|AC|1|N/A
1113A|900|AC|1|N/A
1359B|1000|AC|2|N/A
1182A|1000|AC|1|N/A
1469B|1000|AC|1|N/A
732B|1000|AC|3|N/A
1499B|1000|AC|2|N/A
1566C|1000|AC|1|N/A
753A|1000|AC|1|N/A
72G|1000|AC|1|N/A
706B|1100|AC|1|N/A
363B|1100|AC|1|N/A
313B|1100|AC|1|N/A
368B|1100|AC|1|N/A
1345B|1100|AC|2|N/A
1382B|1100|AC|1|N/A
651A|1100|AC|2|N/A
1478B|1100|AC|3|N/A
1631B|1100|AC|1|N/A
1706B|1100|AC|1|N/A
1637B|1100|AC|1|N/A
522B|1100|AC|1|N/A
331C1|1100|AC|1|N/A
327A|1200|AC|2|N/A
1343C|1200|AC|2|N/A
433B|1200|AC|1|N/A
1354B|1200|AC|2|N/A
1355B|1200|AC|1|N/A
1472D|1200|AC|1|N/A
1272C|1200|AC|1|N/A
1097B|1200|AC|1|N/A
1406B|1200|AC|3|N/A
1598C|1200|AC|1|N/A
1029B|1200|AC|1|N/A
1553C|1200|AC|4|N/A
1485B|1200|AC|4|N/A
961B|1200|AC|1|N/A
1200B|1200|AC|3|N/A
1245B|1200|AC|5|N/A
1042B|1200|AC|1|N/A
1140D|1200|AC|1|N/A
998B|1200|AC|1|N/A
729B|1200|AC|1|N/A
1037C|1300|AC|1|N/A
1466C|1300|AC|1|N/A
1420C1|1300|AC|1|N/A
1660C|1300|AC|1|N/A
1618D|1300|AC|1|N/A
1443B|1300|AC|1|N/A
1176C|1300|AC|1|N/A
1703F|1300|AC|1|N/A
1553B|1300|AC|1|N/A
1178B|1300|AC|1|N/A
628B|1300|AC|1|N/A
777B|1300|AC|2|N/A
870C|1300|AC|2|N/A
1315B|1300|AC|1|N/A
798B|1300|AC|2|N/A
416B|1300|AC|1|N/A
665C|1300|AC|1|N/A
1040B|1300|AC|3|N/A
1535C|1400|AC|1|N/A
1451C|1400|AC|1|N/A
1108D|1400|AC|1|N/A
1706C|1400|AC|1|N/A
1461B|1400|AC|2|N/A
987C|1400|AC|1|N/A
1644C|1400|AC|2|N/A
1276A|1400|AC|2|N/A
1692G|1400|AC|1|N/A
1215B|1400|AC|1|N/A
1282B1|1400|AC|1|N/A
1284B|1400|AC|2|N/A
1415C|1400|AC|2|N/A
1189C|1400|AC|1|N/A
602B|1400|AC|1|N/A
797B|1400|AC|1|N/A
253B|1400|AC|1|N/A
534B|1400|AC|1|N/A
1609C|1400|AC|1|N/A
940B|1400|AC|3|N/A
548B|1400|AC|1|N/A
359B|1400|AC|1|N/A
180C|1400|AC|1|N/A
44E|1400|AC|1|N/A
120F|1400|AC|1|N/A
928B|1400|AC|1|N/A
174B|1400|AC|1|N/A
1385D|1500|AC|1|N/A
1516B|1500|AC|2|N/A
1538F|1500|AC|1|N/A
1304C|1500|AC|1|N/A
1492C|1500|AC|2|N/A
1253C|1500|AC|2|N/A
1547E|1500|AC|1|N/A
1553D|1500|AC|5|N/A
1234C|1500|AC|3|N/A
1307C|1500|AC|2|N/A
1646C|1500|AC|1|N/A
1461C|1500|AC|1|N/A
1313C1|1500|AC|1|N/A
1207C|1500|AC|1|N/A
1673C|1500|AC|1|N/A
1005D|1500|AC|1|N/A
877B|1500|AC|1|N/A
1051C|1500|AC|2|N/A
891A|1500|AC|2|N/A
1614C|1500|AC|1|N/A
264B|1500|AC|1|N/A
1408C|1500|AC|1|N/A
611C|1500|AC|1|N/A
553A|1500|AC|1|N/A
1659C|1500|AC|1|N/A
855B|1500|AC|2|N/A
332B|1500|AC|2|N/A
1084C|1500|AC|1|N/A
1738C|1500|AC|2|N/A
873B|1500|AC|1|N/A
991D|1500|AC|1|N/A
340D|1500|AC|2|N/A
1081C|1500|AC|2|N/A
1739C|1500|AC|1|N/A
761C|1500|AC|4|N/A
858C|1500|AC|4|N/A
204A|1500|AC|1|N/A
859C|1500|AC|1|N/A
255C|1500|AC|1|N/A
868C|1500|AC|1|N/A
159D|1500|AC|1|N/A
22B|1500|AC|1|N/A
191A|1500|AC|1|N/A
566F|1500|AC|3|N/A
417A|1500|AC|2|N/A
10B|1500|AC|3|N/A
212E|1500|AC|2|N/A
74B|1500|AC|2|N/A
1336A|1600|AC|2|N/A
1389B|1600|AC|1|N/A
706C|1600|AC|1|N/A
1373D|1600|AC|1|N/A
1519D|1600|AC|2|N/A
1395C|1600|AC|1|N/A
1528A|1600|AC|2|N/A
1295C|1600|AC|1|N/A
446A|1600|AC|1|N/A
1513C|1600|AC|2|N/A
1455D|1600|AC|1|N/A
1567C|1600|AC|1|N/A
165C|1600|AC|1|N/A
1288C|1600|AC|1|N/A
1537E1|1600|AC|2|N/A
1632C|1600|AC|1|N/A
1633D|1600|AC|1|N/A
1555D|1600|AC|1|N/A
1469C|1600|AC|4|N/A
1282B2|1600|AC|1|N/A
1151B|1600|AC|7|N/A
788A|1600|AC|1|N/A
1196D2|1600|AC|1|N/A
607A|1600|AC|4|N/A
1498C|1600|AC|1|N/A
1109A|1600|AC|1|N/A
660C|1600|AC|2|N/A
429B|1600|AC|2|N/A
1689C|1600|AC|1|N/A
913C|1600|AC|1|N/A
1452D|1600|AC|1|N/A
603A|1600|AC|1|N/A
1709G|1600|AC|1|N/A
835C|1600|AC|2|N/A
416C|1600|AC|2|N/A
1238C|1600|AC|1|N/A
1722E|1600|AC|1|N/A
1677A|1600|AC|1|N/A
1714D|1600|AC|1|N/A
219C|1600|AC|2|N/A
777C|1600|AC|1|N/A
407B|1600|AC|1|N/A
817C|1600|AC|1|N/A
1741E|1600|AC|1|N/A
71C|1600|AC|2|N/A
573B|1600|AC|1|N/A
734C|1600|AC|2|N/A
1033C|1600|AC|1|N/A
812B|1600|AC|3|N/A
741B|1600|AC|2|N/A
375B|1600|AC|2|N/A
597B|1600|AC|1|N/A
756B|1600|AC|1|N/A
107B|1600|AC|3|N/A
209A|1600|AC|1|N/A
637D|1600|AC|4|N/A
316B2|1600|AC|1|N/A
126B|1700|AC|3|N/A
349B|1700|AC|1|N/A
1360F|1700|AC|1|N/A
276D|1700|AC|1|N/A
1324E|1700|AC|2|N/A
1516C|1700|AC|2|N/A
546D|1700|AC|2|N/A
1335E1|1700|AC|1|N/A
1626C|1700|AC|1|N/A
567C|1700|AC|1|N/A
385C|1700|AC|1|N/A
4D|1700|AC|2|N/A
1473D|1700|AC|1|N/A
1249E|1700|AC|2|N/A
1392D|1700|AC|3|N/A
1625C|1700|AC|1|N/A
225C|1700|AC|1|N/A
1528B|1700|AC|3|N/A
1476D|1700|AC|1|N/A
1422C|1700|AC|1|N/A
1743C|1100|AC|1|N/A
1732B|900|AC|2|N/A
279C|1700|AC|5|N/A
1681D|1700|AC|1|N/A
1557C|1700|AC|2|N/A
1619E|1700|AC|3|N/A
1491C|1700|AC|1|N/A
1278C|1700|AC|1|N/A
1497E1|1700|AC|1|N/A
711C|1700|AC|1|N/A
1257D|1700|AC|2|N/A
1239A|1700|AC|2|N/A
1512G|1700|AC|1|N/A
915C|1700|AC|2|N/A
1693B|1700|AC|3|N/A
1051D|1700|AC|1|N/A
1583C|1700|AC|1|N/A
518D|1700|AC|1|N/A
1562D1|1700|AC|1|N/A
269B|1700|AC|1|N/A
1692H|1700|AC|1|N/A
798C|1700|AC|1|N/A
1743D|1700|AC|2|N/A
106C|1700|AC|1|N/A
1561D1|1700|AC|1|N/A
718A|1700|AC|1|N/A
1202B|1700|AC|3|N/A
766C|1700|AC|1|N/A
685A|1700|AC|6|N/A
294B|1700|AC|3|N/A
627A|1700|AC|5|N/A
924C|1700|AC|1|N/A
1032C|1700|AC|1|N/A
1580A|1700|AC|1|N/A
201A|1700|AC|1|N/A
35D|1700|AC|1|N/A
163A|1700|AC|1|N/A
101B|1700|AC|3|N/A
76D|1700|AC|1|N/A
524B|1700|AC|1|N/A
44H|1700|AC|1|N/A
176B|1700|AC|1|N/A
1571E|1700|AC|1|N/A
1398D|1800|AC|1|N/A
1509C|1800|AC|1|N/A
1437C|1800|AC|1|N/A
1475D|1800|AC|1|N/A
1401D|1800|AC|3|N/A
1525D|1800|AC|1|N/A
1327E|1800|AC|1|N/A
1381B|1800|AC|2|N/A
1221D|1800|AC|1|N/A
1442A|1800|AC|1|N/A
1286A|1800|AC|1|N/A
1038D|1800|AC|5|N/A
580D|1800|AC|2|N/A
1335E2|1800|AC|2|N/A
543A|1800|AC|2|N/A
1409E|1800|AC|4|N/A
1446B|1800|AC|1|N/A
1535D|1800|AC|1|N/A
1096D|1800|AC|2|N/A
1637D|1800|AC|1|N/A
1491D|1800|AC|3|N/A
1394A|1800|AC|5|N/A
519D|1800|AC|1|N/A
1283E|1800|AC|1|N/A
830A|1800|AC|2|N/A
1620C|1800|AC|1|N/A
148D|1800|AC|1|N/A
1678B2|1800|AC|1|N/A
1728D|1800|AC|1|N/A
1635D|1800|AC|1|N/A
983B|1800|AC|1|N/A
1720D1|1800|AC|3|N/A
1083A|1800|AC|2|N/A
1748C|1600|AC|2|N/A
1734D|1800|AC|1|N/A
933A|1800|AC|1|N/A
274B|1800|AC|1|Understand that finding the minimum number of required subtractions and the minimum number of additions and summing up their counts yields the correct answer.
909C|1800|AC|1|N/A
527D|1800|AC|5|N/A
1718A1|1800|AC|5|N/A
671A|1800|AC|3|N/A
1133E|1800|AC|5|N/A
869C|1800|AC|1|N/A
946D|1800|AC|2|N/A
1675F|1800|AC|3|N/A
768C|1800|AC|2|N/A
1107D|1800|AC|1|N/A
358D|1800|AC|2|N/A
1016C|1800|AC|1|N/A
917A|1800|AC|4|N/A
666A|1800|AC|3|N/A
914C|1800|AC|3|N/A
733C|1800|AC|3|Understand that as long as its possible to segment `a` into segments with sums equal to `b`, and each segment does not consist of only two equal monsters, it is possible to find a solution greedily.
822D|1800|AC|1|N/A
747D|1800|AC|1|N/A
1740E|1800|AC|2|N/A
351A|1800|AC|2|N/A
626D|1800|AC|1|N/A
402D|1800|AC|3|N/A
846C|1800|AC|1|N/A
38E|1800|AC|1|N/A
847E|1800|AC|2|N/A
845D|1800|AC|2|N/A
132C|1800|AC|2|N/A
533E|1800|AC|2|N/A
167B|1800|AC|1|N/A
1575D|1800|AC|3|N/A
73C|1800|DNF|1|N/A
187B|1800|DNF|3|N/A
49D|1800|AC|1|N/A
79C|1800|AC|3|N/A
30C|1800|AC|2|N/A
180E|1800|AC|2|N/A
234F|1800|AC|1|N/A
575H|1800|AC|1|N/A
182E|1800|AC|1|N/A
95B|1800|AC|1|N/A
448C|1900|AC|1|N/A
1353E|1900|AC|4|N/A
1479B1|1900|AC|1|Understand that only one state needs to be kept track of each time: the value of the end of the previous segment. This is because the value of the end of the current segment is always the previous segment, and because the values at the beginning and end of adjacent segments matter when merging segments. With this in mind, we can use dynamic programming with a segment tree to query for maximal values for segments ending in either a certain value, or any value but a certain value. We must also use prefix sums since we need to account for all the different adjacent pairs within each segment. And finally, the transitions represent switching colors.
1155D|1900|AC|2|N/A
1313C2|1900|AC|2|N/A
1475G|1900|AC|1|N/A
1238D|1900|AC|1|Understand that there are three different cases for each right-hand substring index. Let `i` be the current index, `j` be the greatest index such that `j < i && a[j] == a[i]` and `k` be the greatest index such that `k < i && a[k] != a[i]`. If `j` doesn't exist, no palindrome greater than length `1` can exist either. If `k` doesn't exist, all previous indices can be palindromes. If both exist and `j < k`, all indices `l` such that `l <= j` can be left-hand substring indices, since indices `l` where `l > j` will end in `a[i]` but not begin with `a[i]`. If `j > k`, then there is exactly one index that does not begin a palindrome: `k`.
505C|1900|AC|1|N/A
1512F|1900|AC|2|N/A
1413C|1900|AC|2|N/A
455B|1900|AC|7|N/A
1494C|1900|AC|1|N/A
459E|1900|AC|2|N/A
1700D|1900|AC|3|N/A
1197D|1900|AC|1|N/A
540D|1900|AC|1|N/A
1214D|1900|AC|2|N/A
510D|1900|AC|1|N/A
479E|1900|AC|1|N/A
1383B|1900|AC|1|N/A
687C|1900|AC|1|N/A
1119E|1900|AC|3|N/A
1558B|1900|AC|1|N/A
1153D|1900|AC|2|Understand that dynamic programming storing the minimum count above and maximum count below the maximal value for each node is enough to solve the problem. For `min` nodes, the maximum value cannot have a smaller above count than the sum of all its children's above counts as well as the total number of children minus one. For `max` nodes, the maximum value cannot have a smaller above count than the minimum of all its childrens amove counts.
1749D|1900|AC|1|N/A
1718A2|1900|AC|1|N/A
557C|1900|AC|1|N/A
366C|1900|AC|2|N/A
1613D|1900|AC|1|N/A
1200D|1900|AC|1|N/A
1384B1|1900|AC|2|N/A
1746D|1900|AC|3|Understand that all paths should end at leaf nodes, this is because any remainders when splitting an amount of paths between children can be accounted for through said children. Now, all that is left is to distribute the path ends to the leaf nodes. We can set the initial counts to the final quotient of all divisions along the path, then greedily increase counts by at most `1` such that the result is maximum.
16E|1900|AC|1|Understand that bitmask dynamic programming can be used to calculate and transition states where certain combinations of fishes are still alive.
1000D|1900|AC|3|Understand that, for each index `j`, each previous beginning index `i` contributes `lCa[i]` subsequences, where `l` is `j - i - 1` and `a[i] > 0`.
1172B|1900|AC|1|Understand for all nodes `i` such that `i != 1`, the number of possible permutations is `(k + 1) * k!`, where `k` is the number of children of `i`, `(k + 1)` different counts of children left and right of node `i` and `k!` different orderings. For node `1`, the number of possible permutations is `n * k!`, where `n` is the total number of positions and `k` is the number of children of node `1`, `n` different places to root the tree and `k!` different orderings of children.
1689D|1900|AC|1|Understand that the distances can be represented as a sort of "convex hull", where each line on each axis represents the distance to that node on that axis. The hull is made by maximizing among all such lines for the given position on each axis. Calculating this hull can be done using dynamic programming. Finding the minimum point on this hull can be found through a complete search.
597C|1900|AC|1|Understand that the problem can be solved with knapsack dynamic programming except each transition takes a range query instead of a point query, this can be accomplished with a point update range sum data structure like Fenwick tree.
19B|1900|AC|2|Understand that, as long as the final time taken is greater than or equal to the amount of items stolen, there exists some permutation of items where such moves are possible.
1260D|1900|AC|9|Understand overlapping ranges can be joined into and traversed as one, saving time. With this in mind, binary search along `a` with prefix sums can be used to find the maximal number of soldiers that can reach the boss.
148E|1900|AC|2|Understand that range dynamic programming for each index `i` can be used to solve for the maximal damage for each quantity of items at `i`. Then, knapsack dynamic programming can be used to find the maximal damage over all indices where the final quantity is `m`.
685B|1900|AC|6|Understand that the centroid can only decrease in depth going from a child node to a parent node, so binary lifting can be used to find the parent's centroid from any child's.
1077F1|1900|AC|3|Understand that, between two reposts, their distance cannot be greater than `k - 1`. We can use dynamic programming to simulate this for `x` reposts. (Note to self, for 1077F2, remember that by "each segment of the news feed of at least `k` consecutive pictures", the problem means "each subarray of length `k`". This misunderstanding cost me `2` submissions!)
650B|1900|AC|4|Prefix sums can be used to calculate the cost of going `i` photos from the left or right of the starting photo `0`. In the case of going only one direction, just the prefix sum can be used to calculate total time. In the case of going one direction, then the other, both prefix sums and binary search can be used to find the maximum distance possible under the time limit.
582B|1900|AC|2|Understand that the maximum longest non-decreasing subsequence consisting of only unique indices has length `n`, and since each repeat of the original array contributes at least `1` element to the sequence, we can calculate the longest non-decreasing subsequence of the original array repeated `min(n, t)` times. For the remaining repeats, we can find the most common value in the array, as it will be contributed the most during said repeats.
1015E2|1900|AC|2|Understand that each row and column can be simplified into bounds. For each cell, a star of maximum size can be calculated using said bounds, then drawn onto another grid. If the final grid matches the input grid, a solution exists, and if a solution exists, the stars of maximum size found earlier form the solution.
9D|1900|AC|1|Understand that for each binary search tree of size `i`, we can transition from trees of size `j` and `k`, where `j + k == i - 1`, representing the left and right children. The maximum height can also be kept, for a final complexity of `O(N ^ 4)`.
1611E2|1900|AC|7|Understand that if all children of a node are solvable, then the parent is too. In addition, if the distance to a friend is less than or equal to the distance to Vlad, the node is solvable. The total number of friends needed is the number of nodes where the distance to a friend is less than or equal to the distance to Vlad, this is because Vlad is unable to reach those nodes.
811C|1900|AC|6|Using range dynamic programming to solve for all ranges, and then dynamic programming again using said ranges as transitions.
682D|1900|AC|2|Using grid dynamic programming we can find the longest common subsequence with exactly `x` disjoint segments.
750D|1900|DNF|0|N/A
981D|1900|AC|3|Understand that a dynamic programming can be used to maximize each bit of the answer in decreasing order of significance. The final complexity is `O(L * (N ^ 2) * K)`.
1181C|1900|AC|1|Understand that 2D prefix sums can be used to determine whether a rectangular region consists entirely of one color. Finding contigious rows of one color along each column, treating these rows as the middle rows of a flag and the column as the left bound of the flag, then binary searching for a right bound using the region checking from earlier yields a solution in `O(N * M * log2(M))`.
1012C|1900|AC|1|Understand that knapsack dynamic programming keeping track of the state of the previous hill can be used to solve the problem. The states of the previous hill `i` is `excavate(i, i - 1)`, `excavate(i, i + 1)` and `a_arr[i]`, where `excavate(i, j)` represents the height of `i` after excavating it to a height below that of `j`.
149D|1900|AC|2|Understand that the brackets form a tree, which allows us to solve the problem using dynamic programming on trees. The states represent the color of the leftmost and rightmost brackets of each node, if any.
796C|1900|AC|1|Understand that dynamic programming on trees can be used to solve for each root, where the pattern is that the root has `0` additional strength, nodes adjacent to the root have `1` additional strength and all other nodes have `2` additional strength. Finding the minimum among all roots yields the solution.
109C|1900|AC|1|Understand that dynamic programming on trees can be used to find the number of nodes such that the path to said nodes contains at least one lucky edge. Combinatorics can then be used to find the number of ordered pairs of nodes `j` and `k` for each node `i` such that both the paths from `i` to `j` and `i` to `k` contain a lucky edge.
1799D1|1900|AC|1|Understand that dynamic programming with states representing the "other" CPU (one or the other is always used in the previous program).
893D|1900|AC|3|Understand that we can calculate the minimum and maximum addition at each index. For every deposit, we can maximize the balance and deposit again when this balance is no longer sufficient. We can handle this using dynamic programming.
1774E|1900|AC|1|Understand that, while one piece ventures deeper into the tree, it is advisable for the other piece to stay as shallow as possible, since following the first piece would take the same number of moves and moving away from it would take more moves otherwise.
730J|1900|AC|2|Using a technique I discovered solving the [USACO 2023 US Open Gold problem "Pareidolia"](http://www.usaco.org/index.php?page=viewproblem2&cpid=1330), pairs can be used in dynamic programming in cases where one parameter is more significant than another. This saves both performance and memory usage.
1183H|1900|AC|2|Understand that the problem can be simplified to finding the number of unique subsequences of length `i` for each length `[1, n]`. This can be done using `upper_bound` on the indices of all letters of the alphabet. By only transitioning to a certain letter once after each subsequence, we guarantee that the subsequence resulting in adding this letter is not counted more than once.
321B|1900|AC|4|Understand that, by sorting both Jiro and Fox's cards by increasing strength, we ensure that Fox's weakest possible card is used against each of Jiro's cards. One thing of note in this problem is the fact that, if Jiro runs out of cards, all of Fox's remaining cards can directly effect damage on Jiro. This means we can do dynamic programming for two different cases: one where Jiro does not run out of cards and one where they do. In the case where Jiro does not run out of cards, Fox is allowed to skip cards with no effect on the answer. But in the case where Jiro *does* run out of cards, each of Fox's skipped cards can be used once Jiro runs out of cards, and thus, contributes to the answer in this case.
1067A|1900|AC|3|Understand that dynamic programming can be used to restrict the maximum size of a relative maximum to at least 2 elements wide.
1794D|1900|AC|2|Understand that the number of `m` for any combination `y` of `n` unique prime factors is `n! / (cnts[x[0]]! * cnts[x[1]]! * ... * cnts[x[k - 1]]!) / ((cnts[y[0]] - 1)! * (cnts[y[1]] - 1)! * ... * (cnts[y[n - 1]] - 1)!)`, where `cnts` is a histogram of all the numbers in `a`, and `x` is an array of length `k` containing all numbers not in `y`. Using this, we can use dynamic programming to find the sum for all `y`, producing the answer.
372B|1900|AC|1|Understand that 2D prefix sums can be used to query which rectangles consist entirely of zeros and 2D range dynamic programming can be used to find the number of such rectangles within a range of rows and columns.
633C|1900|AC|1|Understand that a trie can be used to store and query all words in `O(W)`, where `W` is the maximum length of a considered word. By traversing the trie at each index of `t`, transitions can be made for every word completed. Indices that are unreachable are also ignored.
568B|1900|AC|1|Understand that, in order to satisfy the properties symmetric and transitive but not reflexive, at least one element `a` in `A` must not have a pair `(a, a)` in set `ρ`. In order to satisfy just symmetric and transitive, however, all pairs `(a, b)` must also have a `(b, a)` in set `ρ`. In the context of graphs, this means that all connected components (connected via pairs) form dense graphs. We can represent this in dynamic programming by either choosing to start a new component or to join an existing component. Finally, for all possible quantities of elements `i` represented in `ρ`, there can be `nCi` different sets of elements satisfying said quantity.
1808C|1900|AC|2|Understand that digit dynamic programming with state representing the minimum digit and value representing the maximum digit can be used to solve for the minimal number.
351B|1900|AC|1|Understand that the permutation is sorted only when all inversions are resolved. In all of Jeff's moves, he should always try to resolve one inversion. However, in all of Furik's moves, he could either introduce or resolve an inversion with equal probability. This makes it so that, for every pair of Jeff and Furik's moves, the net decrease in inversion count is either `0` or `2` with equal probability. If the net decrease is `0`, then another pair of moves is executed, and so on until the net decrease is finally `2`. This comes out to an expected value of `4`. With this, the answer is simply the number of decreases required to get to `0` or `1` multiplied by the expected value of each decrease, plus `1` if there is still `1` inversion remaining, representing Jeff's final move.
417D|1900|AC|5|Understand that bitwise dynamic programming can be used to find the optimal set of friends for every maximum number of monitors. Using bit tricks, this can be done in `O(N * 2 ^ M)`.
222E|1900|AC|2|Understand that matrix exponentiation can be used, where the each element `mat[i][j]` represents whether or not `[i, j]` is a valid chain (`mat[i][j] = 1` if valid).
613B|1900|AC|8|Understand that brute forcing for all different maximum level skill counts can be used the maximum result.
292D|1900|AC|1|Understand that the state of the parent array (disjoint set union) can be kept at each prefix and suffix, taking `O(N * M)` preprocessing. Then, for each query, the parents of each node at prefix `l` and suffix `r` can be treated as edges, allowing the union to be re-calculated in `O(N)` per query. The final complexity is `O(N * M + N * K)`.
1801C|1900|AC|1|Understand that each album must contribute its maximum coolness to the final impression. With this, it would be optimal to sort the albums by maximum coolness. Now dynamic programming can be used to find the most optimal album before each album.
930C|1900|AC|2|Understand that, in order for it to appear that no two segments are disjoint, there cannot exist a relative minimum, as that would require two disjoint segments around the minimum. Finding the maximum length subsequence such that the aforemention holds yields the optimal answer.
335B|1900|AC|3|Understand that, if there are more than `100` of any character, a palindrome can be formed with just that character. This brings the maximum string length unsolvable via this method down to `26 * (100 - 1)` or roughly `2500`, which allows us to solve the problem with an `O(K ^ 2)` dynamic programming solution, where `K = 2500`.
41D|1900|AC|3|Understand that dynamic programming can be used to find the optimal path, where each state keeps track of the number of peas modulo `k + 1`.
404D|1900|AC|1|Understand that pretty simple transitions can be made between the states `*` (mine), `0` (`0` neighbors are mines), `*1` (`1` neighbor is a mine, satisfied), `#1` (`1` neighbor is a mine, unsatisfied), `2` (`2` neighbors are mines).
213B|1900|AC|1|Understand that we can find the number of combinations for each leading digit using the binomial formula and dynamic programming in `O(D * D * N)`, where `D` is the number of digits, `10`.
883I|1900|AC|1|Understand that binary search can be used to find the minimal difference between minimum and maximum for each group by limiting the range of each transition in the dynamic programming-based checking function.
223B|1900|AC|4|Understand that dynamic programming can be used to find the maximal `t` index for each index in `s` starting from the beginning of `s` and the minimal `t` index for each index in `s` starting from the end of `s`. Then, checking if all of the maximal indices are greater than the minimal indices yields the answer.
262C|1900|AC|1|Understand that, the total number of `swap` executions is equivalent to the number of inversions in the permutation. Thus, we want to make a swap that minimizes the number of resulting inversions. To do this, we can use prefix sums to simulate removing or inserting a given value from the permutation and brute force for every pair.
285D|1900|DNF|0|N/A
137D|1900|AC|1|Understand that knapsack dynamic programming can be used where transitions are substrings with costs equal to the minimum number of characters that need to be changed to make them palindromic.
158E|1900|AC|2|Understand that the beginning of each segment, as well as the end of the day can be checked against all endings having skipped `i` segments where `i` is in range `[0, k]`. This can be done using dynamic programming.
14E|1900|AC|1|Understand that dynamic programming keeping track of whether the previous digit was increasing or decreasing (to find extrema), as well as the number of local maxima and minima can be used to find the number of sequences satisfying `t` maxima and `t - 1` minima.
258B|1900|AC|1|Understand that digit dynamic programming can be used to find the number of numbers in range `[1, m]` such that the number of lucky digits is `i` for all `i`. Then knapsack dynamic programming can be used to find the number of ways such that the net luckiness is greater than `0`, where the Little Elephant Political party contributes positive luckiness equal to the number of lucky digits in their number and all other parties contribute negative luckiness in a similar fashion.
279E|1900|AC|2|Understand that each "group" of `1`s costs two beautiful integers. This is because, to enter a group at index `i`, it costs one beautiful integer `2 ^ (i + 1)` and one `-1`. To exit a group at index `i`, it costs one `-(2 ^ (i + 1))` and one `1`. However, since `1` and `-1` are used, they can both be cancelled out for a net cost of `2`. Meanwhile, in cases where only one digit needs to be added or subtracted, the net cost is just `1`. Using dynamic programming, we can apply both these strategies to find the optimal answer.
232B|1900|AC|3|Understand that, as one column leaves the window (square), another column with the same number of points must enter. This means that we only need to process each index of the square to get the answer for the entire table, and can do so using exponents. Finally, knapsack dynamic programming and the binomial formula can find the number of ways to fill a square with `k` points.
261B|1900|AC|2|Understand that we can find the number of permutations for each `i` such that it is impossible to fit the `i`th customer at position `j`, then divide by the total number of permutations excluding the `i`th customer at position `j`.
208B|1900|AC|1|Understand that the states of the next three cards can be kept, as they are the only relevant cards that could be affected by a move.
67D|1900|AC|2|Understand that, after sorting each ray by their starting position, any decreasing subsequence of ending position will produce a group such that all rays intersect every other ray. To find the largest such subsequence, we can used longest decreasing subsequence dynamic programming.
173C|1900|AC|3|Understand that larger spiral sums can be calculated by subtracting a smaller spiral sum and one cell from a square the size of the larger spiral. The square sums can be calculated using prefix sums.
69D|1900|AC|2|Understand that there are rougly `D ^ 2` positions that are within `D` units from the radius. Dynamic programming can be applied to this problem with position, whether or not each player has reflected their dot and whose move it is.
46E|1900|AC|2|Understand that prefix sums going up or down the possible values of `c` for each row depending on the index as well as dynamic programming to transition between rows suffices.
1132F|2000|AC|1|Understand that there are two types of transitions possible if we solve this problem using range dynamic programming. We can either break one range into two different ranges (sum the ranges), or, join three ranges such that the left and right ranges are of the same character. To handle the second transition, we can fix a single character on the right as the right range. By allowing the second range to have `0` length, we effectively allow the second transition to happen to triples of any length of first, second and third ranges.
1379C|2000|AC|2|Understand that we can simplify the problem to choosing a number of first flowers, and sticking to just one flower for the remaining flowers. This is because, if more than one flower is chosen for the remaining flowers, a better answer could be reached by using only the flower with with the highest `b` value.
1294F|2000|AC|2|Understand that, for each subtree, we can define states where one or two nodes are already chosen. Then, for each node, we can find the best combination of one-node and two-node subtrees, or the best triplet of one-node subtrees.
1426F|2000|AC|1|Understand that we can keep track of the index of "abc" of the latest character in the subsequence(s) just like in a normal subsequence problem. However, for every '?', we must multiply the counts of each index by `3`, representing the ways identical prefixes can branch.
1391D|2000|AC|1|Understand that it is impossible for an even-length square sub-matrix of length greater than `2` to have an odd number of ones. This is if all square sub-matrices of length `2` have an odd number of ones, square sub-matrices of size `4` will always have an even number of ones since it has an even number of disjoint square sub-matrices of size `2` within them. In addition, if either the number of rows or columns is equal to `1`, no cells need to be changed as no even length square sub-matrices can be formed. Finally, dynamic programming with bitmasks can be used to handle widths in range `[2, 3]`.
710E|2000|AC|1|Understand that stacks (much like convex hull trick) can be used to find the cheapest way to delete to a length. Other than that, dynamic programming can be used to find the cheapest way to add or double to a length.
1296E2|2000|AC|1|Understand that all inversions need to be resolved for the string to become sorted. Going from start to end, if a character `a` greater than the current character `b` comes before the current character, the two will inevitably meet and need to have different colors. If `a` has a character `c` also greater and before it, then `b` will also have this character `c` to deal with. This means that `b`'s color cannot equal `a`'s nor `c`'s. With this observation, the problem because a longest decreasing subsequence problem, and can be solved as such.
1716D|2000|AC|1|Understand that, after each `k`, the earliest place `k + 1` can start from increases in a quadratic fashion, meaning the problem can be solved in `O(N * sqrt(N))`.
1616D|2000|AC|1|Understand that each right bound has a minimum left bound from which a subsegment could be formed. Dynamic programming can be used to transition from any state between the minimum left bound to the maximum left bound (just before the right bound) and skip either one or two elements.
453B|2000|AC|2|Understand that each `b[i]` must be coprime, and so the usage of primes could be represented using a bitmask. Transitions represent the different ways of combining primes to reach a certain value close to `a[i]`.
895C|2000|AC|4|Understand that a number is a square if all its factors are represented an even number of times. We can represent this using the parity of each factor in a bitmask for all possible factors.
1408D|2000|AC|2|Understand that we can find the number of `b` increases needed for each `a` increase to reach a safe configuration using dynamic programming. Each pair of robbers and searchlights can be compared and an interval can be calculated such that, for all `a` increases before a certain threshold, the `b` increase needs to be at least a certain amount.
1101D|2000|AC|1|Understand that centroid decomposition can be used to maximize across all paths containing each centroid. The factors of the running `gcd` and their distances from root need to be kept track of during the tree traversal of each child of the centroid. Then, it is compared against all other children of the centroid to ensure their path passes through said centroid.
1257E|2000|AC|1|Understand that, if we create prefix sums for the number of problems initially taken by each participant within any range, we can formulate an expression for the cost of dividing problems between the second and third contestant for each prefix assigned to the first contestant. The expression for each contestant is as follows: `ps2[i] - ps2[0] + ps3[i] - ps3[0]`, `ps1[j] - ps1[i] + ps3[j] - ps3[i]`, and `ps1[n] - ps1[j] + ps2[n] - ps2[j]` for the first, second and third contestand respectively, where `i` is the prefix ending index, `j` is the suffix starting index and the sum of each expression is the cost of moving each contestant's problems into each their range. By minimizing their sum for each `i`, we only have `j` to worry about. If we rearrange the sum of the expressions, `ps2[i] - ps2[0] + ps3[i] - ps3[0] + ps1[j] - ps1[i] + ps3[j] - ps3[i] + ps1[n] - ps1[j] + ps2[n] - ps2[j]` and keep only the `j` terms, we get `ps3[j] - ps2[j]`. And since `j` must only be greater than or equal to `i`, we can evaluate this for each `j` and find the minimum along each suffix `j`.
598E|2000|AC|1|Understand that dynamic programming for the width, height and number of squares suffices.
792C|2000|AC|1|Understand that digit dynamic programming keeping track of the value modulo `3` suffices. (I only noticed after submitting my solution, I had not multiplied the running value by `10` before adding the current digit. Interestingly, it still passed!)
1223D|2000|AC|5|Understand that the answer is the number of unique elements minus the longest contiguous range of values such that the ranges formed by the minimums and maximums of each value in this range are disjoint. This is because any prefix or suffix of values can be moved to the beginning or end of the sequence while the infix would remain sorted.
1566E|2000|AC|1|Understand that nodes can be colored, red for nodes that are leaves at any point in time and black for nodes that are ever buds. Also understand that no node can ever be both a leaf and a bud or neither. Now, the solution can be found by, for each node, finding the number of buds not included from the path from root to said node, subtracting this count from the total number of leaves and minimizing this value among all nodes.
864E|2000|AC|3|Understand that, first sorting the items by the moment in which it is burned, then doing knapsack dynamic programming for time yields the maximal answer.
1506G|2000|AC|2|Understand that a stack can be used, where, at each index such that the character is not currently in use, while the back of the stack is not the last possible occurence of its character and also less than the current character, pop back.
1416C|2000|AC|2|Understand that different levels of significance can be solved independently. Also understand that the number inversions resulting in inverting a bit is equal to the total number of pairs minus the number of inversions before inversion, assuming all numbers have the same bits leading up to the inverted bit. Using these two observations, the costs of inverting each bit can be found and it can be determined whether it is optimal to invert said bits.
1716C|2000|DNF|0|N/A
1256E|2000|AC|3|Understand that, after sorting the students by skill, the total diversity can be calculated as the maximum skill minus the minimum skill minus the "cuts". A cut is the difference between two adjacent students in the sorted array and represents a border between teams. Using dynamic programming we can find such cuts that minimize the total diversity while maintaining teams of at least three students.
1804D|2000|DNF|0|N/A
629D|2000|AC|1|Using a segment tree we can do dynamic programming transitioning from all `j` such that `j < i` and `volume(j) < volume(i)`.
401D|2000|AC|3|Understand that, similar to bitmask dynamic programming states for each count of each digit could be kept track of, as well as the modulus modulo `m`.
777E|2000|AC|1|Understand that, after sorting in non-increasing order of `b`, range queries can be used, for each ring `i`, to query all previous rings `j` such that `b[i] > a[j]`.
1624E|2000|AC|1|Understand that, if a string can be composed of segments of length at least `2`, then it can also be composed only of segments of length either `2` or `3`.
27E|2000|AC|2|Understand that the prime factors of all numbers with `1000` or fewer divisors do not exceed `17`. Also note that each power of a prime factor multiplies the running total number of divisors by `k + 1`, where `k` is the power of said prime factor. This allows us to run dynamic programming for each prime factor, keeping track of the number of divisors.
1733D2|2000|AC|4|Understand that each state can keep track of the number of unfulfilled operations of the second type as well as whether the current index is inverted. This allows us to simulate operations of the first type by inverting the immediate next index, and the second type, by increasing the number of unfulfilled operations by one and inverting the current index (at `l`) and decreasing the number of unfulfilled operations by one and inverting the current index again (at `r`).
797E|2000|AC|1|Understand that square-root decomposition on `k` suffices. If `k` is less than or equal to the block size, a cached solution can be used. If `k` is greater than the block size, a solution can be calculated, since the maximum number of operations in this case is `n / k`.
1551E|2000|AC|3|Understand that the number of moves required to reach a certain `k` can be calculated using `a[i]`, the element at index `i`, the final index of the subsequence such that `a[i]` matches its index in the subsequence `j`, and `k` itself. Since `a[i]` represents the last element of the subsequence and `a[i]` equals `j`, we know that there are `j + 1` elements in the subsequence, and given `k`, we know that `k - (j + 1)` elements of this subsequence don't match their indices. Finally, we can treat all elements after `i` as part of the subsequence, regardless of whether their value matches their index in the subsequence or not. This yields a sum of `k - (j + 1) + n - (i + 1)` elements in the subsequence, or `n - (k - (j + 1) + n - (i + 1))` moves required. We can minimize this value among all last elements of possible subsequences of length greater than or equal to `k` to find the answer.
1680E|2000|AC|1|Understand that it is always to keep a "cursor" which holds the current single chip. The process is finished when the final (the rightmost) chip is overlapped by the cursor.
1582E|2000|AC|1|Understand that the problem could be simplified to a longest increasing subsequence problem, where each segment size (index) is handled individually, as opposed to generally in a typical longest increasing subsequence problem.
1082E|2000|AC|4|Understand that we can define the cost of adding all the `x`'s in a segment to `c` as the number of `x`'s in the segment minus the number of `c`'s in the segment. We can use prefix sums to solve at each occurence of each `x` this maximum cost.
1753C|2000|AC|2|Understand that, given `m` different unordered pairs `i` and `j` from a set of `n` elements, the expected number of operations until a valid swap is `1 / (m / (n * (n - 1) / 2))` operations.
1458B|2000|AC|6|Understand that keeping track of the total available amount in each state allows us to pre-emptively empty or fill cups. In addition, constant time sliding window maximum can be achieved using deque when transferring variable amounts of water.
487B|2000|AC|1|Understand a segment tree could be used to find the maximum index `upps[i]` such that all `a[upps[i]]` before this index `i` are within `s` from `a[i]`. Then another segment tree could be used to transition from `i` to `[i + l, i + upps[i] + 1]`.
1646D|2000|AC|1|Understand that, for a node `a` to be good, all neighboring nodes need to have weights less than the weight of `a` if `a` has more than one neighbor or less than or equal to the weight of `a` if `a` has exactly one neighbor. This means that no two good nodes can be next to each other, unless the tree consists of just two nodes. Thus, we can color the graph to find the optimal solution.
346B|2000|AC|3|Understand that a prefix function can be used to keep track of what prefix of the virus the running prefix falls on by choosing a certain character. The rest is paths on grids dynamic programming.
940E|2000|AC|1|Understand that each subarray should be either length `c` or length `1`. This is because, all subarrays of length `k` such that `k % c != 0` can be comprised of separate subarrays of length `c` and `1`. Moreover, two subarrays of length `c` can only result in either an equal or more optimal reduction than a single subarray of length `2 * c`. This is because the sum of the two least numbers across a range of `2 * c` considers the two separate least numbers across two consecutive ranges of `c`, but has the option of choosing the two minimum numbers in either consecutive range.
893E|2000|AC|3|Understand that we can use the binomial forumula to distribute prime factors of `x` across the indices `[1, y)`. Then, the number of ways to distribute signs such that their product is positive is equal to `2 ** (y - 1)`.
235B|2000|AC|1|Understand that the problem can be solved by adding up the contribution of every subarray of maximum consecutive `O`'s. This contribution can be solved using calculus.
1030E|2000|AC|7|Understand that, in order for a set of numbers to produce an `xor` of `0` using the provided operation is if the total number of bits is even and no number holds more than half the total number of bits. Since there are only `log2(a)` different bit counts, we can complete search across all bit counts the property above to get the answer.
8C|2000|DNF|0|N/A
997B|2000|AC|1|I was only able to solve this problem by solving for various `n` using dynamic programming and replicating the pattern in code. This problem should be revisited in the future.
1060E|2000|AC|2|Understand that we can color the nodes in alternating colors. This results in nodes of the same color being reachable using only the new tunnels and nodes of different color being reachable using only one old tunnel. Dynamic programming can be used to simulate this.
1796D|2000|AC|2|Understand that dynamic programming can be used to subtract the minimum valid visited prefix from all valid prefixes of various `k`. The key to solving this problem is keeping an eye on bounds.
474E|2000|AC|1|Understand that segment tree can be used to query all ranges such that the provided property holds true.
900D|2000|AC|1|Understand that bitmask (a variable base version of it) dynamic programming can be used to solve for all sequences with `gcd` represented by the bitmask. This can be used to find the number of sequences with `gcd` `1` and length `y / x`.
629C|2000|AC|2|Understand that the number of ways to produce a bracket sequence of a certain with a number of unclosed brackets can be found using dynamic programming. After finding the number of unopened and unclosed brackets in the string `s`, generated bracket sequences can be paired to form valid sequences.
758D|2000|AC|6|Understand that each transition is represented by a valid digital representation of a base ten number.
264C|2000|AC|3|Understand that, for the solution to run under the time limit, each query must be handled in constant time. For this to be the case, we make two observations: an array of prefix maximums for each color can be kept to handle transitioning between two balls of the same color and two maximums can be kept to handle transitioning between balls of different color, since either maximum has to be a different color from the current ball.
360B|2000|AC|3|Understand that binary search on the maximum absolute difference can be used, with dynamic programming being used to test each value.
963B|2000|AC|1|Understand that an "order" can be generated for the children of each node. If a child should be deleted before its parent, its color should be `0`. If a child should be deleted after its parent, its color should be `1`. If the root's color is `1`, there is no order that allows the tree to be destroyed, since the root has no parent to be destroyed before it. The color of a node can be determined from the colors of its children. For each child of color `0`, the parent's parity is flipped. If the parent's parity after all children of color `0` are deleted is odd, the parent's parent must be deleted first to make it even.
353D|2000|DNF|0|N/A
494B|2000|DNF|0|N/A
128C|2000|AC|1|Understand that each axis can be solved independently and that prefix sums can be used to store all widths/heights less than a certain amount.
621E|2000|AC|2|Understand that each additional block contributes a fixed amount from one remainder to another. This allows us to use matrix exponentiation to find the answer.
1209E1|2000|AC|1|Understand that finding the columns with the `min(n, m)` greatest maximums and then brute forcing for all cyclic shifts of these columns yields the optimal answer.
633D|2000|AC|4|Understand that the elements form an ancestor graph, where each pair of elements represents a node. Finding all nodes with zero indegree and then finding the length of its subsequent chain produces all fibonacci-ish sequences.
571B|2000|AC|2|Understand that the expression could be described as splitting the array into "chains", where there are `n % k` chains of length `floor(n / k) + 1` and `n - n % k` chains of length `floor(n / k)` and the cost of each chain is the maximum of the chain minus the minimum. Knapsack dynamic programming can be used to find these chains as contiguous subsegments on a sorted array.
611D|2000|AC|4|Understand that the beginning and end of the previous substring can be kept at every state. Meanwhile, comparing substrings can be improved by sorting the substrings lexicographically and representing each substring as its index in this sorting.
1610D|2000|AC|1|Understand that the combination of elements in a subsequence could be represented as a multi-variable expression, where there exists a constant term as well as linear terms for each of the elements. The constant term equals the sum of all `a[i] * (a[i] + 1) / 2` for each `i` in the subsequence, while each linear term represents the offset `a[i] * f[i]`, where `f[i]` equals the offset of `i`. In order for a subsequence to be good, it must be possible to assign integer values to `f[i]` for all `i` in the subsequence such that the sum of the expression is `0`. This is only possible if the `gcd` of all `f[i]` divides the constant term. Note that, if `a[i]` is odd, `a[i] * (a[i] + 1) / 2` is actually a multiple of `a[i]` and can be merged with its respective `f[i]`. That is to say, any odd `a[i]` does not contribute to the constant term, and it follows that a subsequence consisting of only odd `a[i]` is always good. Furthermore, since the `gcd` of any odd and even pair of numbers is `1`, and `1` divides all numbers, any subsequence containing an odd `a[i]` is good. These are key observations because they can be expanded upon by formulating all numbers as a specific power of two multiplied by a certain coefficient. Now, if all coefficients are odd, the subsequence is always good, and if at least one coefficient is odd, the subsequence is good too. This works because, in addition to the previous observations, divisibility still holds if either operand is multiplied by the same factor. This allows us to finally put together an algorithm: if there are any odd coefficients assuming a maximal power of two `f` such that `f` divides all terms in the expression, the subsequence is good.
213C|2000|AC|4|Understand that the positions of Furik and Rubik can be kept at each row of the square for a complexity of `O(N ^ 3)`
1248D1|2000|AC|5|Understand that we can use knapsack dynamic programming to store whether the indices of the swap has been chosen.
786A|2000|AC|1|Understand that a player loses if all their moves result in their opponent winning, and a player wins if any of their moves results in their opponent losing. We can keep track of the number of opponent wins reachable at each index (to keep updates constant) and update indices for each player one-by-one until no more updates can be made.
999F|2000|AC|1|Understand that knapsack dynamic programming can be used to determine how to distribute cards of each number to the players that want them.
1731E|2000|AC|1|Understand that net cost of an operation is always `1`. This is because there are always `m` edges to add, and each operation costs one more than the number of edges `k` it adds. This means we want as few operations as possible. This can be accomplished by greedily choosing the largest possible `k`. Note that the quantity of pairs of numbers (edges) in range `[1, n]` resulting in a `gcd` of `k` is the number of coprime pairs of numbers in range `[1, floor(n / k)]`. Using this, we can preprocess the number of comprime pairs for all `n` using dynamic programming.
615C|2000|AC|1|Understand that dynamic programming can be used to solve the problem, where each state keeps track of its corresponding indices in both `s` and `t`.
1612E|2000|AC|2|Understand that, since `k` is small, we can brute force the expected value for all values of `t` using dynamic programming.
156C|2000|AC|1|Understand that two strings coincide as long as both the sum of the indices of their characters and their lengths are equal. We can preprocess for the number of strings of all possible sums and lengths using dynamic programming.
1157F|2000|DNF|0|N/A
696C|2000|AC|2|Understand that matrix exponentiation can be used to handle the key switching between the middle cup and either non-middle cup.
814D|2000|AC|1|Understand that, since a circle is either completely inside or completely outside every other circle, it is possible to construct a tree based on whether or not a circle is inside another circle. This allows us to use dynamic programming on trees to find the optimal spaciousness.
509C|2000|DNF|0|N/A
855C|2000|AC|1|Understand that knapsack dynamic programming on trees can be used to find the number of ways.
21C|2000|AC|2|Using prefix sums we can find, for each suffix at index `i` that equals one-third the total, the number of prefixes at index `j` of equal sum such that `j < i - 1`.
82D|2000|AC|1|Understand that at most one customer will be out of order at any given time. We can use dynamic programming to keep track of this customer.
78C|2000|DNF|0|N/A
314C|2000|AC|3|Understand that each `i` transitions from all `j` such that `j < i && a_arr[j] < a_arr[i]` and all `j` such that `j < i && a_arr[j] == a_arr[i]`. Also note that the contribution of each `i` such that there exists `j` such that `j < i && a_arr[j] == a_arr[i]` should not include that of any such `j`.
296B|2000|AC|1|Understand that dynamic programming, keeping track of whether either condition is satisfied suffices.
258C|2000|AC|2|Understand that we can brute force for each possible `lcm` `x` and use combinatorics, provided the number of `a[i]` such that `a[i] >= y` for each `y`, to find the number of ways an array `b` can be made such that the `lcm` of all elements in `b` is equal to `y`.
75D|2000|AC|1|Understand that the maximum prefixes, suffixes and subarrays of each small array can be kept and used to simulate consecutive subarrays of the big array spanning multiple or just one subarray.
689E|2000|AC|1|Understand that the contribution of any range is equal to `l * xCk`, where `x` is the number of segments that cover it and `l` is the length of the range. This can be done for all `2 * n - 1` (maximum) unique non-overlapping ranges with endpoints equivalent to those provided in the input via segments.
379D|2000|AC|3|Understand that dynamic programming can be used to represent the number of times each string touches another string (including itself). Dynamic programming can also be used to determine the existence of a string starting or ending with 'A', 'C' or neither with a certain number of "AC" substrings internally. Complete searching for the number of internal "AC" substrings combined with the number of "AC"'s formed through neighboring strings can be used to find the answer, if it exists.
87C|2000|DNF|0|N/A
201C|2000|AC|3|Understand that any assortment of moves is valid as long as the histogram of the number of visits for each bridge is even, then odd, then even again, where each "section" is allowed to be zero-length. However, the visits still need to be continuous, meaning there cannot be a bridge left unvisited between two sections of visited bridges. This can be accomplished using prefix sum prefix maximums, setting the prefix sum to zero for every bridge that can be visited at most zero times.
852B|2000|AC|1|Understand that matrix exponentiation can be used to simulate the paths between layers.
54C|2000|AC|1|Understand that the quantity of numbers between `L` and `R` that satisfy the given property can be found by greedily calculating the count for `L - 1` and `R` and finding their difference. Then, knapsack dynamic programming can be used to find the probability of any number of random variables having an `MSD` of `1`, which can then be totalled among all quantities at least `K%` of the random variables.
958C2|2000|AC|1|Understand that knapsack dynamic programming can be used to keep track of the number of parts so far, and dynamic programming to keep track of the modulo of the current part.
251C|2000|AC|3|Understand that `a` modulo `2`, `3`, `4`, `5`, ..., `13` (and other primes and their powers no greater than `k`) produce a reasonably sized set of states that repeat when reducing `a` to `b`. The number of operations between states can be solved using Dijkstra's algorithm.
18D|2000|AC|4|I'm not quite sure how someone might go about this problem in C++, but the problem can be solved by greedily winning and selling the largest possible memory stick, which can be determined by checking whether the period between winning and selling the stick is unoccupied by any other previous memory stick.
18E|2000|AC|2|Understand that dynamic programming can be used to keep track of the optimal pairs of alternating characters at each layer.
39E|2000|AC|6|Understand that, if there is only one move that can be made for a given player, the outcome of the game can be predicted without the need for exploration. Otherwise, the problem can be solved using dynamic programming.
374D|2000|AC|1|Understand that a point update range query data structure can be used to keep track of the indices remaining points.
119C|2000|AC|5|Understand that the complexity, number of days accounted for, and number of exercises of the latest subject should all be kept track of in solving this problem using dynamic programming.
261C|2000|AC|3|Understand that for each `m`, the final `m + 1` row contains `1 << (popcount(m) - 1)` ones, meaning that digit dynamic programming can be used to find all `m` such that `m <= n` and `popcount(m) == log2(t) + 1`. Note that the pattern formed for each `m` is similar to the left half of a Sierpiński triangle and, for future reference, the number of colored cells in a Sierpiński triangle at row `x`, assuming the triangle does not recurse past a one-by-one cell, is `1 << popcount(x)`.
435D|2000|AC|2|Understand that prefix sums for each row and column can be used to check if an axis-aligned side consists entirely of white nodes. Then, for each "source node", we can radiate along the x or y axis various triangles, brute force checking the diagonals and using the prefix sums to check the axis-aligned sides.
1057C|2000|AC|2|Understand that the boxes can be processed in non-decreasing order of candy amount, then dynamic programming for number of seconds `t` for each index `i` can be used to calculate whether ending at box `i` after `t` seconds results in at least `k` candies being eaten.
413D|2000|DNF|0|N/A
386C|2000|DNF|0|N/A
63E|2000|DNF|0|N/A
66E|2000|DNF|0|N/A
228C|2000|DNF|0|N/A
774J|2000|DNF|0|N/A
1571F|2000|DNF|0|N/A
1486D|2100|DNF|0|N/A
1433F|2100|DNF|0|N/A
1372D|2100|DNF|0|N/A
1312E|2100|DNF|0|N/A
455C|2100|DNF|0|N/A
319C|2100|DNF|0|N/A
1420C2|2100|DNF|0|N/A
1409F|2100|DNF|0|N/A
1560F2|2100|DNF|0|N/A
1366E|2100|DNF|0|N/A
1393D|2100|DNF|0|N/A
486D|2100|DNF|0|N/A
1479B2|2100|DNF|0|N/A
1516D|2100|DNF|0|N/A
1117D|2100|DNF|0|N/A
734E|2100|DNF|0|N/A
1614D1|2100|DNF|0|N/A
372C|2100|DNF|0|N/A
1667B|2100|DNF|0|N/A
1446C|2100|DNF|0|N/A
1025D|2100|DNF|0|N/A
985E|2100|DNF|0|N/A
1271E|2100|DNF|0|N/A
936B|2100|DNF|0|N/A
1354E|2100|DNF|0|N/A
1265E|2100|DNF|0|N/A
1367F1|2100|DNF|0|N/A
1151E|2100|DNF|0|N/A
1472F|2100|DNF|0|N/A
354C|2100|DNF|0|N/A
1482E|2100|DNF|0|N/A
466D|2100|DNF|0|N/A
771C|2100|DNF|0|N/A
766E|2100|DNF|0|N/A
1628D1|2100|DNF|0|N/A
1547G|2100|DNF|0|N/A
507E|2100|DNF|0|N/A
1077F2|2100|DNF|0|N/A
1271D|2100|DNF|0|N/A
768E|2100|DNF|0|N/A
960F|2100|DNF|0|N/A
1671E|2100|DNF|0|N/A
1029E|2100|DNF|0|N/A
1223E|2100|DNF|0|N/A
1154F|2100|DNF|0|N/A
1185G1|2100|DNF|0|N/A
525E|2100|DNF|0|N/A
1511E|2100|DNF|0|N/A
1202C|2100|DNF|0|N/A
1106E|2100|DNF|0|N/A
980D|2100|DNF|0|N/A
1771D|2100|DNF|0|N/A
1216F|2100|DNF|0|N/A
1152D|2100|DNF|0|N/A
1593F|2100|DNF|0|N/A
840B|2100|DNF|0|N/A
1767C|2100|DNF|0|N/A
1598E|2100|DNF|0|N/A
1650G|2100|DNF|0|N/A
1778D|2100|DNF|0|N/A
1201D|2100|DNF|0|N/A
431D|2100|DNF|0|N/A
988F|2100|DNF|0|N/A
799D|2100|DNF|0|N/A
229D|2100|DNF|0|N/A
1120C|2100|DNF|0|N/A
1729G|2100|DNF|0|N/A
1027E|2100|DNF|0|N/A
145C|2100|DNF|0|N/A
1799D2|2100|DNF|0|N/A
1525E|2100|DNF|0|N/A
894E|2100|DNF|0|N/A