# Practice Problems Status
Problem|Rating|Correct cases|Attempts|Notes
-|-|-|-|-
723A|800|AC|1|The friends could meet at the position of the middle friend.
1399A|800|AC|1|By sorting the elements, we can remove the front repeatedly as long as the front satisfies the property stated in the problem.
432A|800|AC|2|Understand that, by sorting the students by number of participations, we can greedily put the first three (the ones with the most remaining participations) into a team. The number of such teams made this way that have at least `k` participations remaining is the answer.
490A|800|AC|1|Understand that we can greedily make teams consisting of `1` of each type until we run out of any of them.
1353B|800|AC|1|Understand that greedily swapping the smallest elements in `a` for the largest ones in `b` `k` times or until the swap no longer improves `a`'s sum yields the maximum possible sum of `a`.
1360B|800|AC|1|Understand that, by sorting the players by strength and assigning a prefix to `A` and the complementary suffix to `B`, we can minimize among all prefix/suffix pairs `|max(A) - min(B)|`, or more simply, the difference between any two adjacent elements in the sorted array.
1760A|800|AC|1|Understand that the problem can be simplified to sorting the numbers and taking the median.
1676B|800|AC|1|Understand that, as we cannot add or move candies, we have to reduce all quantities to that of the minimum box.
1742B|800|AC|1|Understand that, if the sorted array is not strictly increasing, it is impossible to make the array strictly increasing.
1669B|800|AC|1|While methods like histograms or multisets/maps might be more succint, they might not be as lightweight as sorting the elements and finding the lengths of all contiguous ranges of same elements.
1473A|800|AC|1|Understand that the sum of the smallest two elements of the array can be used to reduce the values of all other elements if needed using the operation given. If any minimized element still remains greater than `d`, it is not possible.
1618A|800|AC|1|Understand that the first two elements of the sorted array `b` will always be part of `a`, as all other elements are either the remaining element of `a`, or any combination of the three. To find the remaining element of `a`, we know the last element of `b` is the sum of all three elements in `a`, so we subtract the two known elements of `a` from this sum.
1760C|800|AC|1|An easy way to find strongest participant not including onself is to sort the participants by strength, compare all but the strongest with the strongest and then compare the strongest with the second strongest. Overall, it is a neat way to handle an edge case.
1692B|800|AC|1|Understand that in `ceil(c / 2) * 2` operations we can remove `c` duplicates.
1626A|800|AC|1|Understand that, printing all characters appearing twice two times in the same order, each pair will be the same distance away.
1629A|800|AC|1|Understand that running each software will always yield a net increase in RAM, provided that it can be run. Thus, it would be optimal to run the each software in increasing order until no software can be run.
1220A|800|AC|1|Understand that we can greedily make ones, then greedily make zeros because the cost of one one is one zero and the cost of one zero is one one.
1557A|800|AC|1|Understand that the maximum of `f(a) + f(b)` can be achieved by setting one subsequence to the maximum element alone (`a`), and the other to all remaining elements (`b`). This is because, in moving any element from `b` into `a`, we bring the sum closer to `f(a + b)`, the average of the original array.
1487A|800|AC|1|Understand that the only heroes that can never win are the heroes with the lowest levels, since they lose all their fights and have no chance to increase in level.
1792A|800|AC|1|Understand that it is only optimal to use the spell of the first type if there are two monsters with health equal to `1`. This is because the cost to kill each monster in this case is `0.5` spells. However, if the monster's health is greater than `1`, using the first type can only result in a number of castings greater than or equal to the health of said monster. In this case, we would use the spell of the second type as the cost is always `1`.
1705A|800|AC|1|Understand that sorting the people by height, and then comparing the heights of `i` and `i + n` for each `i` in range `[0, n)` allows is to check if its possible to arrange the group photo.
1398B|800|AC|1|Finding all contiguous lengths of `1`'s and then sorting them in non-increasing order of length allows us to greedily assign every odd indexed length to Alice.
1728A|800|AC|1|Understand that it can always be arranged that the color with the largest number of balls is the only one remaining.
1092B|800|AC|1|Understand that sorting the students by skill, then pairing every other student with their adjacent student ensures that either student is the closest cost-wise to the other.
1526A|800|AC|1|Understand that we can sort the array and then collate subarrays `[0, n)` and `[n, 2 * n)` such that every even element is strictly greater than to its neighbors and every odd element is stricty less than its neighbors.
1497A|800|AC|2|Understand that we can use multiset and iterate and erase in range `[0, n)` or until the next value to increase the MEX cannot be found. All remaining values are printed in any order, as they do not contribute to the MEX.
1552A|800|AC|1|Understand that the answer is just the number of indices such that differ between `s` and the sorted version of `s`.
1041A|800|AC|1|Understand that to get the minimum number of stolen computers, we can set `x` to the minimum remaining computer. This way, the minimum number of stolen computers is number of stolen computers between the minimum and maximum remaining computers.
1206A|800|AC|1|Understand that the sum of the maximum elements, `a` and `b`, in `A` and `B` cannot exist in either `A` nor `B` because `a + b` is greater than both maximums and there are no elements greater than the maximum.
1637A|800|AC|1|Understand that dynamic programming can be used to find the rightmost (maximum) element of a sorted prefix and the leftmost (minimum) element of a sorted suffix. If the maximum is greater than the minimum, it is possible to choose a `len` such that the final array is not in non-decreasing order.
1736A|800|AC|1|Understand that, if we are going to do the second operation, we only need to do it once, after we perform the first operation enough times. Thus, we can first find the number of operations required without doing the second operation at all, in case it is not necessary, and then the number of operations required if the we perform the second operation. The answer is the minimum of the two.
1646B|800|AC|1|As we do not need have more blue numbers than we need to, we can simply count one more blue number than red. We can also sort the array and make a prefix of the array blue and a suffix of the array red. This way, the sum of red is maximum and the sum of blue is minimum. Try all prefixes and suffixes to check if the property stated in the problem is possible.
1733A|800|AC|1|Understand that, since swaps can happen between any two indices equivalent modulo `k`, it is possible to rearrange all the maximums at indices modulo `k` into a prefix of window `k`. The sum of these maximums is the answer.
1720B|800|AC|1|Understand that we can take the two largest numbers and the two smallest numbers as both maximums and both minimums. Between them, a proper subsegment resulting in their sum can always be chosen.
1734A|800|AC|1|Understand that, by first sorting the array, the difference between each adjacent element is minimum. This way, using a window of three elements, we can minimize the difference between the minimum and maximum in the window among all windows.
1430B|800|AC|1|Understand that all but the maximum element can be added to the maximum. If we add them to the maximum in non-increasing order, we can maximize the maximum.
1656A|800|AC|1|Understand that `i` can be the index of the mininum element and `j` can be the maximum. This is true because all `a[k]` will be both greater than `a[i]` and less than `a[j]`, making `|a[i] - a[k]| + |a[k] - a[j]| = |a[i] - a[j]|` valid.
1445A|800|AC|1|Understand that pairing `a[i]` with `b[n - 1 - i]` will produce the smallest sum possible with respect to other pairs of `a[i]` and `b[j]`. If all sums are less than or equal to `x`, a rearrangement is possible.
1767B|800|AC|1|Understand that each movement results in a net increase in `a[0]`, so the smaller `a[i]` should be added to `a[0]` before the larger `a[i]`. Added them in non-decreasing order yields the maximum possible `a[0]`.
984A|800|AC|2|Understand that the result is the lowest median (if there are two).
1450A|800|AC|1|Understand that "trygub" contains inversions. By sorting the string, inversions are not possible and therefore, "trygub" cannot be a subsequence of the sorted string.
1688B|800|AC|2|Understand that the number of trailing zeros a token has is equal to the number of reductions required to make it odd. This way, we can sort the tokens by their trailing zero counts. If the smallest trailing zero count is `0`, we can fuse all tokens of non-zero trailing count with a token with a trailing count of `0`. If the smallest trailing count is not `0`, we can reduce it until it becomes odd, then fuse all other numbers with it.
1798A|800|AC|1|Understand that assigning the minimum of `a[i]` and `b[i]` to `a[i]` and the maximum of `a[i]` and `b[i]` to `b[i]` for all `i` ensures that no swap can be made to improve the state of `a` and `b`. If the property stated in the problem is still not satisfied, it is impossible.
1561A|800|AC|1|Understand that the constraints are small enough that we could simply run the sort and count the iterations until sorted.
1617A|800|AC|1|Understand that if `a`, `b` or `c` is not present in `s` or `t != "abc"`, the sorted `s` is the answer. Otherwise, print all `c` before all `b`.
551A|800|AC|1|Understand that a sorted copy of the array can be created and `upper_bound` can be used to find the number of elements strictly greater than each element.
609A|800|AC|1|Understand that we can first sort the USBs in non-increasing order, then greedily write to each USB until the `m` megabytes are entirely written.
1670A|800|AC|2|Understand that only a prefix of the array can be negative, otherwise the array cannot be sorted.
937A|800|AC|1|Since all numbers greater than or equal to a certain threshold greater than zero get awarded a diploma, the number of ways to award diplomas is equal to the number of unique non-zero scores.
1305A|800|AC|1|The problem could be seen as this: take the two maximums from `a` and `b`, `x` and `y`. Their sum will never equal the sum of any other pair from `a` and `b` because all `a[i]` and all `b[i]` are distinct, and `x + y` is greater than all other pairwise sums. Do this `n` times to find the answer.
1738A|800|AC|1|Understand that, unless the count of both types of skills are equal, the top `m` of each type are represented twice. If both types of skills have the same count, `m` of one and `m - 1` of either types are represented twice.
1740B|800|AC|1|Understand that, if we sort the slices of cheese in non-decreasing order, the total perimeter is equal to the maximum height multiplied by the total width. With this, we can binary search for maximum height against total width to minimize their sum.
992A|800|AC|1|Understand that the number of seconds required is the number of unique non-zero numbers. This is because all elements of the same value will be handled in the same second, and all zeros don't need to be accounted for.
169A|800|AC|1|Understand that, after sorting the chores, the chore at index `b - 1` is the minimum value of `x` and the chore at index `b` is one greater than the maximum value of `x`.
291A|800|AC|1|Understand that a map can keep track of the id of each call Polycarpus' secretaries are in, as well as the number of secretaries in the call. The answer is the number of calls with exactly two secretaries in them, and Polycarpus has a mistake in the records if there exists a call with greater than two secretaries in it.
769A|800|AC|1|Since Igor joins `x` groups on either side of his year, the answer is the median of the years of the groups Igor joined.
160A|900|AC|1|Understand that we can greedily collect the coins with the greatest values until the total is greater than the remaining.
405A|900|AC|1|Understand that switching the gravity is equivalent to sorting the columns.
1535B|900|AC|1|Understand that the only way reordering the array can increase the number of good indices is if we can make `gcd(a[i], 2 * a[j]) > 1`. We can do this by sorting by parity, where even elements come first, then odd.
768A|900|AC|1|Understand that we can use a sorted map and remove the least and greatest entries. The remaining sum is the number of stewards with other stewards of value strictly greater and strictly less than their value.
1420A|900|AC|1|Understand that the number of swaps required is equal to the number of inversions in the array. If there are greater than `n * (n - 1) / 2 - 1` inversions, Wheatley won't sort the array. There are greater than `n * (n - 1) / 2 - 1` when the array is strictly decreasing.
1272A|900|AC|1|Understand that, in order to reduce pairwise distance, the leftmost and rightmost friend should be moved closer to each other. Moving the middle friend does not make any difference from the total.
1216B|900|AC|1|Understand that it is optimal to shoot the more durable cans first, since the factor in which their durability is multiplied is less.
807A|900|AC|1|If there are any rating differences, the round was rated. Otherwise, if the ratings are in non-increasing order, it is impossible to tell.
1665B|900|AC|1|Understand that the count of each value could be taken. The value with the greatest count can be set as the final value of all the elements of the array. Also understand that cloning, then swapping yields a `log2(N)` solution worst case.
1480B|900|DNF|0|N/A
1427A|900|AC|1|Understand that, if the sum of the numbers is greater than `0`, starting with the positive numbers, then ending with the negative numbers ensures all prefixes has positive (non-zero) sum. If the sum is negative, negative then positive ensures all prefixes have negative sum. Finally, if the sum of the numbers is equal to `0`, it is impossible to arrange the numbers such that all prefix sums are non-zero because the `n`th prefix has sum `0`.
1144B|900|AC|1|Understand that we can only remove at most `min(|E|, |O|) + 1` elements from both the set of even numbers `E` and odd numbers `O`, of course limited by their respective sizes.
1248B|900|AC|1|Understand that we want to invest as large a distance in one dimension as possible and as small a distance in the other. This is because, as `theta` approaches `PI / 4` (away from the axes), the sum of the `x` and `y` components of the unit vector are greater than the sum of the components when the unit vector is aligned with one of the axes. With this, we want to minimize `theta`.
1668B|900|AC|1|Understand that ordering the people by non-decreasing order of distance ensures that, between any adjacent pair of people, the distance wasted is minimum.
572A|900|AC|1|Understand that we can choose the `k` smallest elements from `A` and the `m` largest elements from `B` and if the largest element from the selected portion of `A` is less than the smallest element in the selected portion of `B`, a selection is possible.
1093B|900|AC|1|Understand that sorting the characters in the string makes the string as assymetric as possible, as elements on the left will be less than those on the right if possible. From here, if the resulting string is still a palindrome, a rearrangement is impossible.
1584C|900|AC|1|Understand that sorting both `a` and `b` and adding one to `a[i]` for each `i` where `a[i] != b[i]` will yield the solution if possible.
16B|900|AC|1|Understand that it is optimal to get the matchboxes with the most matches first.
1106C|900|AC|1|Understand that the groups should be as small as possible, since for every number `x` added to a group of sum `y`, an additional `2 * x + y + x * x` is added to the total. In addition, to minimize the sum of each group, the largest number should be paired with the smallest number repeatedly until no more numbers are available. This is because, for each number `a`, if paired with a smaller number `b`, an even larger number `c`, otherwise paired with `b`, would get paired with a larger number, which is not optimal. If paired with a larger number `d`, `a` could be paired with a smaller, more optimal, number.
1198B|1600|AC|1|Understand that updates can be handled in reverse, such that only the last single update is handled at each index. In addition, said update is also maximized with the running range update maximum.
1198A|1600|AC|3|Understand that we can calculate the maximum number of unique values that fit within the disk, then use a sliding window to find the maximum number of unchanged elements possible.
1461D|1600|DNF|0|N/A
1140C|1600|AC|4|Understand that sorting the songs by beauty, then querying the `k - 1` longest remaining songs (not including the current one) to find the total length suffices.
231C|1600|AC|1|Understand that after sorting the array, we can, for each element in the array, query how many elements less than it can be made equal to it in less than or equal to `k` operations with binary search.
1151D|1600|AC|2|Understand that the dissatisfaction `a * j + b * (n - 1 - j)` can be reformulated as `b * (n - 1) - (b - a) * j`. This means we can sort each `(b - a)` in increasing order and greedily subtract each one by their resulting index.
1566D2|1600|AC|1|Understand that it is optimal to put smaller indices on the right and larger ones on the left. Also note that the people enter the hall in non-decreasing order of sight level. This means that the only freedom of order that we have is how groups people of equal sight level are ordered. Obviously, through our first observation, they should be ordered in non-increasing order. However, if such a group spans multiple rows, it is possible for one to occupy a suffix of a row, in which case it would be optimal for the suffix to be as small as possible. With this, we can initially sort each group in non-decreasing order to ensure that such a suffix would be small, then sort them within each row in non-increasing order.
1077D|1600|AC|1|Understand that binary search can be used to find the maximum number of cuts that can be made, which can then be used to greedily produce an answer.
1665C|1600|AC|4|Understand that each node with children should have at least one child be injected. Since only one injection may happen each second, it would be optimal to inject the children of nodes with the most children first, as spreading would take care of as many nodes as possible that way. Afterwards, binary search can be used to determine how many of the remaining nodes should be injected or spread to.
1165E|1600|AC|1|Understand that to achieve a minimum sum of products of two arrays, we multiply the `i`th largest in one array with the `i`th smallest in the other for all `i`. To modify this to solve our problem, we can multiply the contribution of each index `i` to the sum with `a[i]` prior to sorting.
1029C|1600|AC|1|Understand that coordinate compression and prefix sums can be used to find the size of each subset of intersections, as well as how many segments overlap it. Then, prefix sums can be used again to find the cost of removing a segment.
350C|1600|AC|2|Understand that destroying the bombs in increasing order of absolute `x` (and increasing order of absolute `y` for equal `x`) ensures that the robot would not run into another bomb in the process of picking up and disarming a bomb.
493C|1600|AC|1|Understand that, after sorting both `a_arr` and `b_arr`, we can use two pointers to find the number of `2` point shots scored by either team provided a sorted array of all relevant `d` (at most `n + m` unique values).
1781C|1600|AC|1|Understand that we can brute force for the total number of unique characters in the string `t`, since there are at most `26` unique characters. For each unique character count `i`, we choose the `i` most common characters in string `t`, since they would require the least number of characters to be replaced to equal them.
525C|1600|AC|2|Understand that we can sort the sticks by length, an greedily pair valid pairs of equal length sticks (possibly after an operation) to form rectangles.
1082C|1600|AC|4|Understand that we can sort the subjects in non-increasing order of the number of candidates who specialize in them. Then we can complete search for all quantities of unique subjects, and then the number of candidates per subject within each of them. To get the maximum sum of skill levels for each number of candidates, we can take the prefix sums at each number of candidates and add it to the total cost of said number of candidates if the prefix is non-negative. Maximizing along the complete search results in the optimal answer.
599C|1600|AC|1|Understand that it is possible to find the closest index `j` for each index `i` such that the swap would result in the position of `h[i]`. All swaps that "tangle" (their ranges intersect) must form a block since their necessary swaps interfere with each other. Using this, we can find how many groups of swaps do *not* tangle, resulting in the answer.
822C|1600|AC|1|Understand that for all departure dates, we can minimize the cost of the sum of the voucher and any other voucher whose arrival date precedes the departure. We can do this by complete searching among all dates and keeping a running minimum of the cost of all durations such that their arrival is before the current date.
1028C|1600|AC|4|Understand that, if we first search for candidate `x` values using prefix sums along just the `x` axis, there are at most `3` candidates to check the `y` values for.
1137A|1600|AC|1|Understand that the minimum `x` for each intersection `(i, j)`, provided arrays of unique values for each row `i` and column `j`, `R[i]` and `C[j]`, respectively, is equal to `max(|k ∈ R[i] | R[i][k] < R[i][j]|, |k ∈ C[j] | C[j][k] < C[j][i]|) + max(|k ∈ R[i] | R[i][k] >= R[i][j]|, |k ∈ C[j] | C[j][k] >= C[j][i]|)`. This is because the intersection value `a[i][j]` serves as a fixed point in both the set of values in row `i` and column `j`, meaning that all values less than `a[i][j]` in row `i` (call it `X`) must each have a unique value and same goes for the column `j` (call it `Y`). This could be represented as the maximum of the cardinality of both sets. In similar vain, we can apply the same logic to all values greater than or equal to `a[i][j]`.
593B|1600|AC|1|Understand that if the order of the lines right after `x1` and just before `x2` are different, there must have been an intersection in the interval `(x1, x2)`.
858D|1600|AC|1|Understand that coordinate compression can compress the substrings. For each possible substring, we can determine if it corresponds to a singular phone number, and if it does, we can minimize the result for that phone number with the length of the substring.
830B|1600|AC|1|Understand that each contiguous group of same-number cards should be sorted with respect to the last visited index. A point update range query data structure like Fenwick tree can be used to simulate removing and cycling through cards to reach a minimum card.
430A|1600|AC|1|Understand that if segments within segment `[l, r]` have `|r - b| <= 1`, segment `[l, r]` satisfies the property as well. We can ensure this by dividing the ranges into subranges such that each subrange represents a unique subset of segment overlaps. Then, we can divide the subrange into red and blue such that `r - b <= 1` holds. Finally, each subrange now has an `r - b` of either `0` or `1`, we can alternate between `1` and `-1` for each `1` so that now, all segments have absolute difference less than or equal to `1`.
175C|1600|AC|1|Understand that each factor could be treated as multiplying the count of each figure destroyed by said factor, and since we want to destroy more figures of higher cost, we can order the figures in increasing order of cost.
1346C|1600|DNF|0|N/A
1474C|1700|AC|2|Understand that `x` must always be the maximum remaining value, and if it can't be, then the destruction is impossible.
1336B|1700|AC|2|Understand that, for each `r`, we can find the closest `g` such that `g >= r`, then, find the `b` closest to `floor(r + (g - r) / 2)`, since that would yield the optimal `b` given known `r` and `g`. We can repeat this for all permutations of `r`, `g` and `b` and minimize among all of them.
1393C|1700|AC|2|Understand that the problem can be simplified to spacing out the patty-cakes corresponding to the mode filling. For each patty-cake, we can simply append it to the spacing and loop in case the spacing spills over the mode minus one (since we only need spacing *in between* each patty-cake of the mode). This works because these patty-cakes will never overlap itself, that is, unless the count is greater than the mode minus one, in which case we let the remaining one go after the spaced patty-cakes, or clamp it.
559B|1700|AC|1|Understand that if we sort both strings such that, in each sorting operation, if a string can be split into halves, we swap them if the left half is lexicographically greater than the right half, their equality is the answer.
1684D|1700|AC|2|Understand that the reduction in damage from the total is equal to, for all `i` in `inds`, `a[inds[i]] - (inds[i] - i)`, where `inds` is an array of indices, sorted in decreasing order, of length at most `k`. If we separate the terms, note that the total `i` is only dependent on the length of `inds`, and each `inds[i]` can be chosen independently. With this, we subtract `j` from each `a[j]` and choose the `t` greatest for each `t` in range `[0, k]` and maximize for all `t`.
382C|1700|AC|2|Understand that we can solve individually for every number of unique adjacent differences in the sorted array.
1779D|1700|AC|2|Understand that stacks can be used to find the ranges that need to be cut with a certain razor. Then a multiset can be used to determine if there are remaining razors of that type. The answer is whether or not the entire haircut can be completed without running out of the requisite razors.
732D|1700|AC|3|Understand that we can use a segment tree to determine the latest one can start studying to pass all `m` exams. If the latest (going left to right) is greater than `0` and there is enough time to study for and take all exams, the answer can be minimized with the current index.
439D|1700|AC|1|Understand that we can use `upper_bound` and `lower_bound` on the sorted versions of arrays `a` and `b` to find how many `i` such that `a[i] <= x` and `j` such that `b[j] >= x` for `a` and `b` respectively given an `x`. This can then be used along with prefix sums to find the cost of clipping the minimums of `a` and the maximums of `b` along such `x`, the sum of which can be minimized among all `x` in `a` and `b`.
1148C|1700|AC|2|Understand that it is possible to get any element to any position by swapping with either end of the array (whichever possible) as an intermediary step.
1792D|1700|AC|1|Understand that the problem is equivalent to finding the longest common prefix of permutation `i` and the inverse of any permutation `j` among all `j` for each `i`.
1310A|1700|AC|1|Understand that a set can be used to find the next available number of publications for a given `i` with `a[i]` publications. In order to get the optimal answer, we must first sort in non-increasing order of `t[i]`, since more expensive categories should require fewer additions, and then find the next available number of publications for each category, adding to the total each time.
567D|1700|AC|2|Understand that we can assume all shots result in misses, in which case, all remaining cells can be treated as candidates for ships. With this, we can, for each contiguous range of unknown cells, calculate the number of ships that could fit in this range: `c = (l + 1) / (a + 1)`, where `c` is the number of ships, `l` is the length of the range and `a` is the provided `a`. Now, to update the counts of each contiguous range, we can keep track of the bounds of each range using a sorted set, and only update the relevant ranges for each `x`.
1468D|1700|AC|1|Understand that the robber should, firstly, never move towards the guard. Secondly, the robber should always drop all their firecrackers as early as possible, such that the delay until explosion and the robber's fleeing coincide. With this, we can greedily choose firecrackers that can be exploded within the time the robber has.
827A|1700|AC|3|Understand that, at each index, we can determine the string `t` that can predict the string `s` at the latest possible index. For all unknown indices between known indices, we substitute with 'a', the lexicographically smallest character possible.
978G|1700|AC|1|Understand that we can use a sorted set to, for each day, keep track of the most "urgent" exam, the exam that will be administered the soonest, such that the questions have been published already.
729C|1700|AC|4|Understand that the time taken to travel a given distance `d` on a full tank `v` is equal to `2 * d - 1 * min(v - d, d)`, assuming `v >= d`. This is because, if we drive in normal mode the entire distance `d`, it would take `2 * d` minutes, but we would have `v - d` liters of gas left over. We can use these liters of gas to convert normal mode kilometers into accelerated mode kilometers, the cost of which is `1` extra liter, for a decrease in time of `1` minute. Using all `v - d` extra liters, we can decrease the time taken by `1 * min(v - d, d)` minutes, since we cannot drive in accelerated mode on more than `d` kilometers. Using binary search, we can find the prefix and suffix of the sorted array of all distances such that `d` and `v - d` equal the minimum respectively, and solve for them to produce the total time for all distances until the cinema.
631C|1700|AC|1|Understand that we can iterate through all indices where an operation is applied and apply the latest operation, which can be found using a stack. Then, a set can be used to remove either the least or greatest remaining element, depending on the current sorting order.
761D|1700|AC|1|Understand that we can find `b` for indices in increasing order of their corresponding `p`, where each `b` must result in a `c` greater than the last.
895B|1700|AC|3|Understand that, for each `a`, we can find the range of values that satisfy the stated property. Then, we can use `lower_bound` and `upper_bound` on the sorted `a_arr` to find how many `a` lie within said range.
160C|1700|AC|7|Understand that we can treat each pair as a two digit number, where each tens digit can have a different amount of ones.
596C|1700|AC|4|Understand that no `y - x` should occur more than once in a set `S` such that all members of the set have equal `y + x`. This means that we can sort the points by their `y + x` and greedily assign the earliest remaining `w` equivalent to their `y - x`. Then, we can check if the solution is valid and, if so, print the assignment.
1056C|1700|AC|1|Understand that we first go through all hero pairs, since, after choosing the first hero in such a pair, the opponent is forced to choose the second hero, returning the move back to the player. Then, the remaining heroes should be chosen in non-increasing order of power.
925B|1700|AC|5|Understand that, after sorting the array, the leftmost element of a subarray is always the minimum of said subarray. This allows us to do a complete search, starting with the greatest element of the array towards the smallest, for two adjacent subarrays of resource units that satisfy the requirements.
161B|1700|AC|2|Understand that we want as many single-stool carts as possible, with the carts chosen being as high as possible. We can do this by greedily distributing stools to the `k` carts and filling the remaining carts with pens. If there are none remaining, fill the least expensive cart with the pens.
131E|1700|AC|1|Understand that, for each queen, we can add the minor diagonal position, major diagonal position, row and column to vectors corresponding to the queen's major diagonal position, minor diagonal position, column and row, respectively. This allows each queen to query the existence of another queen higher or lower on the minor diagonal, major diagonal, row or column in that order.
81C|1700|AC|1|Understand that, if `a < b`, each unit of each score is worth more in Safety Studies than in PE, and so the `a` greatest scores should be attributed to Safety Studies. If `a > b`, each unit is worth more in PE, so the `b` greatest scores go to PE. If `a == b`, each unit is worth the same in either subject, so the least significant `b` scores are assigned to PE.
216D|1700|AC|1|Understand that `upper_bound` and `lower_bound` on the sorted attachment points of the left and right sectors can be used to find the number of attachment points within the left and right side of a cell respectively.
159E|1700|AC|1|Understand that we can process the colors in decreasing order of count, keeping track of the maximum prefix sum by count after each color. Then, we can maximize the sum of the current prefix sum and a previous maximal prefix sum for all colors to get the optimal answer.
1211C|1700|DNF|0|N/A
1619D|1800|AC|1|Understand that the problem can be reformulated as, at least one store must have gifts for at least two friends. With this, we can, first, find the minimum among all maximum friends' maximum joys `x`. Then, for each store, find the minimum of the two maximum joys `y`. The result is the maximum of `min(x, y)` for all stores.
1156B|1800|AC|2|Understand that, if there are at least `4` unique characters, the characters can be greedily ordered such that no two neighbors are neighboring in the alphabet with each other. Otherwise, we can brute force for the solution using `next_permutation`.
1552C|1800|AC|1|Understand that the circle can be flattened into a line containing coordinates `[0, 2 * n)`. On this line, two chords in the initial circle intersect if their corresponding ranges on the line intersect, but do not contain one another. With this in mind, it would be optimal to pair the first half of the remaining `2 * (n - k)` points with the second half as that would maximize the number of aforementioned intersections. Finally, we can use a point update range query data structure to count the intersections.
1705D|1800|AC|1|Understand that it is possible to reach a lightbulb configuration equivalent to that of `t` as long as the number of contiguous ranges of lightbulbs turned on in both `s` and `t` are the same and both strings have lightbulbs of the same state on each end. Each contiguous range in `s` can be mapped to a range in `t` of the same index, and can be reached, if all previous ranges have been matched, in `abs(l1 - l2) + abs(r1 - r2)` operations, where `l1`, `r1`, `l2` and `r2` are the left and right bounds of the ranges in strings `s` and `t` respectively, since each operation can be thought of extending or reducing a range by `1` lightbulb.
1721D|1800|AC|4|Understand that a breadth-first search can be used to check, for each bit `i` in decreasing order of significance, if it is possible to achieve a result with `i`. If it is, sort the current subarray in opposite order with respect to bit `i`, and queue the subarrays corresponding to the `0` and `1` valued ranges after the sort. Otherwise, skip the current bit and re-queue the current subarray.
1154E|1800|AC|1|Understand that we can use a sorted set to keep track of the remaining players.
1148D|1800|AC|1|Understand that a sequence of type 1 can only exist if all `i` contained in it satisfies `a[i] < b[i]`. Likewise, type 2 can only exist if all `i` satisfies `a[i] > b[i]`. Now, for a type 1 sequence, if the `i` were arranged in decreasing order of `b`, their corresponding `a` cannot be greater than the previous `b`. For type 2, in increasing order of `a`, the corresponding `b` cannot be greater than the following `a`. Sorting in this way guarantees an optimal solution. 
1801B|1800|AC|4|Understand that processing the departments in decreasing order of price for the first friend, then in increasing order of price for the second friend, in this order of significance, allows the problem to be solved for every maximum first price by keeping track of the minimum maximum second price required to achieve said first price. This works because along with the minimum maximum second price, any department whose first price is less than the current maximum first price can be used to buy a gift for the second friend. So to solve at each maximum first price, we can simply take the minimum of 1. the minimum maximum second price, 2. the maximum of the minimum maximum second price and the greatest second price less than or equal to the current maximum first price or 3. the maximum of the minimum maximum second proce and the least second price greater than or equal to the current maximum proce.
1249D2|1800|AC|1|Understand that we can maintain a satisfactory solution to the subproblem containing all segments before the current one. Now it is a matter of modifying the solution to the previous subproblem. Note that, if including the current segment displaces any included segments in the previous subproblem, the cost can only be greater than or equal to the cost of excluding the current segment. Thus, simply including the current segment if there is space produces an optimal solution.
1119D|1800|AC|1|Understand that, first, it is only the number of frets covered by each query's range that affects the number of different pitches, as the left bound will simply shift the pitches and do not affect how they interact. Secondly, the number of frets between strings represents the number of unique pitches achievable before overlap. Sorting can be used to solve each query provided these two observations.
913D|1800|AC|2|Understand that we can binary search for the total number of problems completed to get the optimal solution. Solutions can be checked using a greedy algorithm sorting the time it takes for each problem.
1077E|1800|AC|1|Understand that we are essentially trying to fit an exponential curve underneath the sorted array of topic counts. For this, we can align the exponential curve ending at exponential `i` as far right as possible and determine the maximum initial problem count for all `i``.
922D|1800|AC|1|Understand that the number of "sh" subsequences introduced between a pair of any two `t` is equal to `s * h`, where `s` is the number of 's' characters in the leftmost `t` and `h` is the number of 'h' characters in the rightmost `t`. Using this formula, we can determine the ordering of the strings for any pair of `t`: if `s1 * h2 < s2 * h1`, where `s1` and `s2` are the number of 's' characters in the leftmost `t` and the rightmost `t` respectively and `h1` and `h1` are the number of 'h' characters in the leftmost and rightmost `t` respsectively, then the `t` should be swapped. Rearranging the inequality (`s1 / h1 < s2 / h2`) shows that each `t` is independent, allowing us to sort the entire array of `t` to produce an optimal solution.
1282C|1800|AC|1|Understand that we can simply find and maximize among all the maximum number of problems solvable before each deadline and by the end of the exam.
1005E1|1800|AC|1|Understand that the number of ranges is a matter of choosing left and right bounds of each range. A left and right bound are valid if `a - b <= 1`, where `a` is the number of values greater than `m` within the range and `b` is the number of values less than `m` within the range. Now, we can store, for each left and right index `i`, `a - b` between the index of `m` in `p` and `i`, and simply look up the number of right indices for each left index such that their total `a - b` is less than or equal to `1`.
612D|1800|AC|3|Understand that we can use sweep line to find all segments containing only satisfied points.
652D|1800|AC|1|Understand that processing in increasing order of the right bound of each segment and querying the number of left bounds of already visited greater than the current segment's left bound using a point update range query data structure yields the number of nested segments for each segment.
492D|1800|AC|1|Understand that binary search can be used to find the minimum number of seconds (multiplied by `lcm(x, y)`) `s` to defeat each monster. From there, we can use the remainders of `s % x` and `s % y` to determine if Vanya, Vova or Both made the last hit.
794C|1800|AC|3|Understand that for each player, if placing their most optimal character as close to the front as possible is better than placing their least optimal character as close to the back as possible, they should place their most optimal character as close to the front as possible, and vice versa.
652C|1800|AC|1|Understand that we can keep a multiset of right bounds of all foe pairs. For each index `i`, we can find the smallest right bound such that the corresponding left bound is strictly less than `i` (this can be achieved by removing right bounds from the multiset when their left bound is visited). Then, these range lengths can be accumulated to produce the final result.
853B|1800|AC|1|Understand that we can, for each day `i`, calculate the minimum cost of all jurors arriving in Metropolis before or on `i` as well as the minimum cost of all jurors leaving Metropolis after or on `i`. Using this, we can try every window starting at `i` of size `k` such that the jurors arrive before or on `i` and leave after `i + k`.
432C|1800|AC|6|Understand that, by Goldbach's conjecture, all even numbers can be represented as the sum of at most two primes. Meaning that the cost of all even distance swaps can be represented as the combination of two swaps of one less than a prime. With this, all odd numbers can then be represented as the combination of at most three swaps, as one swap could be of length `1` and cost `2` (which is prime) and the other two travels the remaining even distance. This results in at most `5` swaps per index.
433C|1800|AC|2|Understand that for each page `x` we can find a page `y` such that the total number of page turns is minimal. To find such `y`, we can simply take the median of all pages turned to or from page `x`, as any page before or after the median would include the cost of the median as well as the other pages (which would cancel out) and therefore be greater than if the median was selected. The total number of page turns for each `x`-`y` pair can be minimized among all `x`.
141C|1800|AC|1|Understand that by sorting the people in increasing order of number `a` will always produce an optimal solution if it exists. This is because `a` represents a lower bound to the number of people ahead of them, taller or not (this can also be used to verify if a solution exists). Finally, a vector can be used to determine the actual heights of each person. Since just the heights of people in front of each person is relevant to the solution, one can simply insert at index `a` and forget about it.
140D|1800|AC|1|Understand that, in order to solve the maximum number of problems, we can greedily select the problems that take the least time until no more problems can be chosen. Then, to order the problems, note that any problem solved before the New Year will have `0` cost, since Gennady can distract from the problem he is solving to submit solutions, and any problem solved after the New Year will have cost proportional to the time it is solved after the New Year. With this, we can construct an argument that the optimal solution has the problems solved in increasing order of time consumption: for any two problems `l` and `r` (in increasing order of index), if `l` takes longer to solve than `r`, swapping them will always improve the cost. This is because all problems solved before `l` and all problems solved after `r` won't get affected by the swap, but all problems between `l` and `r` will have reduced costs, since `l` is replaced with `r`, which can be solved sooner. Meanwhile `l` and `r`'s costs are swapped, for a net cost of `0`.
724C|1800|AC|1|Understand that the next intersection can be found by finding the minimum distance to a wall given the current velocity. The velocity can be flipped based on the direction of the wall being collided with (vertical or horizontal).
222C|1800|AC|2|Understand that fast factorization preprocessing can be used to quickly factorize all `a` and `b`. Then all factors shared between the `a` and `b` arrays are removed (quantity matters). The factors are then multiplied together (in order of factorizing, since the existing order already fits) to ensure that the output fits as required.
252B|1800|AC|6|Understand that it is possible to unsort all arrays of length greater than or equal to `4` and some arrays of length equal to `3`. Using this, we can hardcode all solutions to compressed subarrays of length `3` and `4`.
83B|1800|AC|2|Understand that by processing each number of visits `a` in increasing order we can repeatedly "shave off" the number of remaining visits for all unprocessed/processing `a` by the current `a`, and with it, `n * a` from `k`, where `a` is the current `a` and `n` is the number of unprocessed/processing `a`. This happens until the remaining `k` is too small, when the amount shaved off will equal `k / n`, where `n` is the number of unprocessed/processing `a` and the remaining `k` can be used to brute force the remaining visits, as `k <= n`.
370C|1800|AC|1|Understand that, once sorted, for a contiguous range of mittens of color `c` with length `l` to, first, no longer overlap, one side must be shifted `l` times. However, after `n - l` shifts, the range will overlap once again. In addition, a range of mittens of length `l` will always overlap at least `max(l * 2 - n, 0)` times. Using this, we can say that if we shift all mittens by the maximum `l` (call it `L`) among all contigious mitten ranges, the number of distinct mitten pairs is maximum. This is because, if `L` is greater than `n / 2`, it will overlap `l * 2 - n` times, while no other group will overlap themselves at all. if `L` is less than or equal to `n / 2`, they will all be shifted at least `l` times, where `l` is the length of a group, and at most `n - l` times, since `L <= n - l`.
847K|1800|AC|2|Understand that we can sort each unique route in decreasing order of the total cost incurred along said route, then for each of the first `k` routes, minimize between the cost of buying or not buying a travel card for the route. The remaining routes are added to the result without the opportunity of minimization.
1375D|1900|AC|3|Understand that we can keep replacing until the array is sorted. For each iteration, if `MEX == n`, if there is an incorrect index, replace at that index, otherwise the array is sorted. If `MEX != n`, replace at `MEX` with `MEX`. This guarantees at most `2 * n` operations because if `MEX == n`, `MEX` will no longer equal `n` after the current iteration, and if `MEX != n`, one more index will become correct. This process can only happen `n` times for each index possibly incorrect, for a total of `2 * n` replacements.
1444B|1900|AC|1|Understand that, among all `bin(2 * n, n)` valid partitions, the sum is always the `n` greatest `a` minus the `n` least `a`. We know this is true because if we take all `i` such that `x[i] - y[i]` is non-negative and form a sorted array of all `x[i]` and `y[i]` of those `i`, we form an array consisting of all `x` on the upper half and all `y` on the lower half. Same for all `j` such that `y[j] - x[j]` is positive, except `x` appears on the lower half and `y` on the upper half. Combine this with the fact that all `x` in the first group is greater than or equal to the greatest `x` in the first group and all `y` in the second group is greater than or equal to the greatest `y` in the first group, if we merge both lower halves into one array and both upper halves into another, we get two arrays of length `n` such that one contains elements strictly greater than or equal to all elements in the other.
1342D|1900|AC|2|Understand that, if we evenly distribute each array in non-increasing order of size to `x` testcases, we can say that for an array of size `m` and a testcase with `i` arrays, if `i >= c[m]` (the array cannot be added), we need more testcases. This is because all testcases will have `i` or `i + 1` arrays already, both of which are greater than or equal to `c[m]` in this case. With this, we can binary search for the minimum number of testcases required.
1251D|1900|AC|1|Understand that we can pay `floor(n / 2) + 1` employees `i` that can be paid at least `x` (the proposed median) to `max(x, l[i])` and pay the remainder `l[i]`. In order to minimize the cost of this selection, we can greedily pay employees who can be paid at least `x` in non-increasing order of `l` until `floor(n / 2) + 1` such employees are paid. Then, the remaining `floor(n / 2)` employees have the minimum possible `l` for such a median `x`. With this, we can binary search for `x`.
1175D|1900|AC|1|Understand that beginning a subarray at index `i` increases the final cost by the sum of the suffix at `i`. This is because all subarrays `S` that begin at or after `i` will contribute an extra `a[j]` for all `j` in `S`, equivalent to the suffix at `i`. We can greedily select the `k - 1` greatest suffixes to add to the answer.
1701D|1900|AC|3|Understand that binary search can be used to find, for each `i`, a range of `a[i]` that satisfies `floor(i / a[i]) == b[i]`. Now, it is a matter of assigning each range a unique number within said range. This can be done by greedily choosing, for each `i` in increasing order, the range with the least upper bound such that its lower bound is less than or equal to `i`. This works because all other ranges would be capable of being assigned a `j` greater than `i`, and to assign `i` to any other range opens the possibility that a range's upper bound would be too low to be assigned a `j`.
1707B|1900|AC|4|Understand that the only a limited number of non-zero elements can exist among all `n` relevant arrays. This quantity is small enough that brute force can be used to get the final result.
1371E1|1900|AC|1|Understand that for each `a[i]` in a permutation `P` against a value `x`, the index `i` `a[i]` is assigned to must be no less than `a[i] - x`, since at least `a[i] - x` `j` must exist such that `x >= a[j]`. With this observation we can use combinatorics to determine how many valid permutations exist for each candidate `x` modulo `p` and output the satisfactory ones.
1270D|1900|AC|1|Understand that, if we start with an arbitrary selection of length `k`, get the `m`th element and its index, `a[con]` and `con`, respectively, then find one element, not part of the original selection, either greater than or less than `a[con]` by excluding `con` from the next query and including some other index `ref`. This can be determined because, if `con` is removed from the query, the resulting `a[pos]` will be either greater than or less than `a[con]`. If it's less than `a[con]`, it must be because `a[pos]` is less than `a[con]`, "pushing" a smaller value to fill `a[con]`'s place. Likewise with values of `a[pos]` greater than `a[con]`. From this, we can perform queries for each element `cmp` in the original selection, removing them and including `ref` to determine whether `a[cmp]` is greater than or less than `a[con]`. This works in a similar fashion as the first query, in that, if the resulting `a[pos]` is equal to `a[con]`, `a[cmp]` and `a[ref]` must both be less than or greater than `a[con]`, where `a[cmp]` "shifts" `a[pos]` away from `a[con]`, but `a[ref]` "restores" `a[con]`. If `a[pos]` is less than `a[con]`, `a[cmp]` must be greater than `a[con]`, since this can only happen if `a[ref]` is less than `a[con]` to "shift" a small `a[pos]` up to replace `a[con]` and if `a[cmp]` is greater than `a[con]` to provide space for `a[pos]` to be shifted. Similarly if `a[pos]` is greater than `a[con]`, `a[cmp]` must be less than `a[con]`. We can total the number of `a[cmp]` less than `a[con]` to determine `m`.
552D|1900|AC|2|Understand that, for each starting point `i`, we can sort all other points `j` and use `upper_bound` and `lower_bound` to find the number of points `k` such that `i`, `j` and `k` are not colinear.
1569D|1900|AC|1|Understand that a pair is only inconvenient if there are no streets of perpendicular type between the two people. With this, we can check for all gaps between streets of the same direction the number of people within those gaps and use combinatorics to find the number of inconvenient pairs.
1237C2|1900|AC|1|Understand that we can simply the problem by solving one axis at a time. On a one dimensional plane, simply processing the points in increasing order of value and choosing the next greatest point to pair with yields a solution. We can apply this to the problem by first removing all pairs points with the same `x` and `y` (one-dimensional removals along `z`), effectively making the `z` axis irrelevant, then removing all pairs of points with the same `x` (one-dimensional removals along `y`), effectively making the `y` axis irrelevant, and finally removing all pairs of points (one-dimensional removals along `x`). To clarify, by making an axis "irrelevant", we are essentially making sure that all points have a unique value along this axis, removing its restriction on solving the problem, and allowing us to kind of "flatten" along this axis.
817D|1900|AC|1|Understand that the the problem could be re-formulated as the sum of all maximums minus the sum of all minimums. This could be calculated by finding all ranges on which each `a` is a minimum or maximum and subtracting or adding that count multiplied by `a`. This can be accomplished using a segment tree.
3B|1900|AC|3|Understand that this problem can be solved using greedy. By setting the cost of replacing two kayaks with a catamaran as the greatest capacity of a catamaran minus the least two capacities of a kayak, we can keep replacing with catamarans until the total capacity is optimal.
1650E|1900|AC|2|Understand that we can brute force moving each exam into an optimal position using a sorted set.
1311F|1900|AC|1|Understand that if we sort the points by position and create an array of their velocities, for any two points that form an inversion, their minimum distance is `0`. This is because they will eventually coincide. For all other cases, however, their minimum distance is their current distance. Thsi can be totalled using segment tree.
1791G2|1900|DNF|0|N/A
1361B|1900|AC|4|Understand that, once it is impossible to balance the quantity of a `p ** k[i]` among both weeks, simply spending the remaining `p ** k[j]` countering the original `p ** k[i]` produces the optimal solution. To determine if a `p ** k[i]` can be balanced between the weeks, we can check all `p ** k[j]`, where `k[j] < k[i]`, if it is possible to produce a sum identical to the value of the remaining `p ** k[i]`.
437D|1900|AC|1|Understand that, if processed in non-increasing order of `a`, disjoint set union, uniting all already-processed neighbors, simulates the creation of the path having number `f(p, q)` between any two neighbors, where the current `a` represents `f(p, q)`.
1819B|1900|AC|3|Understand that there are only, at most, two possible rectangles: the one with the maximum width among all provided rectangles (first cut is along the width of the rectangle), and the one with the maximum height among all provided rectangles (first cut is along the height of the rectangle). Both can be checked using brute force and sets.
1834D|1900|AC|3|Understand that the problem could be reformulated as the maximum number of topics that at least one student covers, but another doesn't. This could be found by processing all students' range of topics in non-decreasing order of left bound and using sets to keep track of `-r`, `r - l` and `-l` for all already-processed ranges. Then, the maximum of each set can be added with `r`, `l - r` and `l`, respectively, to find the aformentioned value for all overlapping ranges. For ranges that don't overlap, any student's entire range can be considered if there is at least one range that does not overlap with it.
1043E|1900|AC|1|Understand that, for a pair `i` and `j`, `x[i] + y[j]` is optimal when `x[i] + y[j] < x[j] + y[i]`, or `x[i] - y[i] < x[j] - y[j]`. This means that, if we sort all `i` in non-decreasing order of `v = x[i] - y[i]`, we can guarantee that, for all `j` with a greater `v`, `x[i] + y[j]` is optimal and likewise for all `j` of smaller `v`. This allows us to calculate the sum of all pairings using prefixes of `x` and suffixes of `y` and simply subtracting pairings to account for people who don't want to be paired with each other.
118C|1900|AC|4|Understand that producing the lexicographically smallest number for each digit `d` such that there are at least `k` equal `d`, then finding the minimum among all `d` with minimum cost yields the optimal answer.
22D|1900|AC|2|Understand that sorting the segments by right endpoint and adding a nail at the right endpoint when necessary always yields an optimal solution. Think of segments ending before a certain the current segment's right bound as a subproblem with an optimal solution already found. By adding the current segment, if it cannot be nailed down using the already existing nails, then it must be nailed down with a new one. This is because all nails in the existing solution would cause at least one segment to become un-nailed if moved any farther right.
757C|1900|AC|4|Understand that any set of Pokemon types are interchangeable if they have the exact same quantity among all gyms. This can be checked using hashing or trie.
353B|1900|AC|1|Understand that greedily distributing among both heaps produces the optimal solution.
222D|1900|AC|1|Understand that the best place Vasya can get is always first, and the worst equivalent to the maximum number of pairs with total greater than equal to `x`. This can be found using greedy and sets.
524C|1900|AC|2|Understand that we can preprocess a map containing the minimum number `j` of `a[i]` among all `i` to achieve a certain sum. Then, for each query, generate all sums consisting of only `a[i]` for each `i` and minimize their sum with the cost of filling the remainder using the map.
377B|1900|AC|3|Understand that we can binary search for the minimum number of days. If we keep non-increasing versions of the bugs and the students, we can have students with abilities greater than or equal to the current maximum complexity bug handle `x` bugs for an `x` amount of days we would like to test, thereby removing the `x` most complex bugs upon successful selection. This can be implemented using sets.
848B|1900|AC|2|Understand that, any pair of horizontal and vertical grouped dancers will collide if the `w - t` of the vertical and `h - t` of the horizontal are equal. We can apply this to the fact that all collisions initiated by a vertical dancer effectively `pops_back`s the dancer with the highest height. and `push_front`s the vertical dancer. Using this, we can simulate the dancers until we get their final positions.
865B|1900|AC|4|Understand that the problem can be represented as a greedy cost problem, where we start off with all pizzas of type `1` and transform an amount into type `2` based on its cost.
45D|1900|AC|1|Understand that we can re-formulate the problem as assigning a range to each point, if possible, since there are at most `1e7` points to consider. For each point, processed in increasing order of position, assign the range with the least upper bound such that the point is contained within the range. This way ranges with lesser upper bounds will not be "skipped".
119B|1900|AC|2|Understand that simply removing all visited theorems, accumulating a minimum and maximum proficiency using the provided cards, and greedily producing the minimum and maximum proficiency using the remaining cards (if needed) yields the answer.
195D|1900|AC|5|Understand that compression can be used to turn the "bend point" of each piecewise function into points, upon which prefix sums can be used to calculate the slope contribution of each function. Then, at each point, a difference in slope can be checked to count all non-180 degree angles.
120J|1900|AC|1|Understand that all vectors should use a `k` that puts it in the first quadrant, since transforming a vector out of the first quadrant always increases the value of the "absolute value" expression. With this, the problem can be simplified to finding the minimum distance between two vectors, which can be done using sweep line.
529B|1900|AC|4|Understand that we can brute force for all possible heights and greedily choose to lie down people who have the choice to lie down based on their cost of lying down (`h - w`, as that is the amount that would be added to the width if they lied down).
421D|1900|AC|2|Understand that we can go through all `n` coders, remove every accuser of the current coder and query how many other coders have at least `p - cnt` accusers remaining, where `cnt` is the number of accusers of the current coder. This can be done with a point update range query data structure like Fenwick tree.
1657D|2000|AC|1|Understand that for a squad to be able to beat a monster, `h / D > H / (d * n)`, where `h` and `d` are the health and damage of one unit, `n` is the quantity of said unit in the squad and `H` and `D` are the health and damage of the monster. We can rearrange the variables to get `h * d * n > H * D`. This allows a separation of unit and monster, which allows us a lot of freedom in terms of optimization. With this, we can determine, for each cost `t`, what is the highest `H * D` that can be handled. Firstly, we need to define the cost `t` as a relationship between `n` and `c`, `n * c`. Second, we need to solve for minimum integer `n` using the inequality from earlier, `n = floor((H * D) / (h * d)) + 1`. With this, we can define a maximum `H * D` that a unit can handle as `n * (h * d) - 1`. Now, we can apply for all `n * c` less than or equal to `C`, `n * (h * d) - 1`. This can be further optimized by first finding the maximum `h * d` factor for any given `c` and using a `O(C * ln(C))` operation to populate for all `n * c`. Then, since squads of greater `t` can handle weaker monsters, we apply a prefix maximum. Now, all queries can be handled using `lower_bound` on this prefix maximum array to find the minimum `c` that kills the monster.
1244E|2000|AC|7|Understand that we can check the minimum maximum available for each minimum and maximum minimum for each maximum using sorting and prefix sums.
1525C|2000|AC|6|Understand that the time it takes for any two robots to collide is dependent on their direction: `(x[j] - x[i]) / 2` if facing each other, `x[i] + (x[j] - x[i]) / 2` if both facing left, `m - x[j] + (x[j] - x[i]) / 2` if both facing right and `max(x[i], m - x[j]) + (x[j] - x[i] + min(x[i], m - x[j])) / 2` if facing away from each other, where `i < j`. It can be shown that, in all cases, the time taken is no longer than `m`, meaning no robot bounces off a wall more than once. In addition, if two robots meet without ever bouncing off a wall (facing each other), it the time taken is strictly less than if either robot bounces off a wall (facing same direction). And if two robots meet, where one has already bounced off a wall (facing same direction), the time taken is, again, strictly less than if both robots bounced off walls before meeting (facing away). Using this, we can try all cases in increasing order of time taken. This can be achieved using sets and sorting.
1514D|2000|DNF|0|N/A
555B|2000|AC|2|See 45D.
1641B|2000|AC|1|Understand that a solution cannot exist if there is an odd number of any `a`, since we cannot change the parity of this count when we insert two of a number. Furthermore, the question is essentially asking to produce a sequence of numbers, and then repeat it again. What we can do is, set a starting index `i` and, upon reaching an `a[j]` equal to `a[i]`, we simply duplicate all `k` between `i` and `j` after `j`. This requires at most `n ^ 2` operations, as duplications introduce `m` additional indices to process, where `m` is the length of the duplication.
1841D|2000|AC|2|Understand that we can produce all pairs of segments and use sets to find the maximum number of disjoint pairs of segments that we can arrange.
1256F|2000|AC|1|Understand that a reversal of length `x` flips the state of exactly `x * (x - 1) / 2` pairs, where a state is either an inversion or a non-inversion. This means that the parity of the total number of inversions in `s` and `t` must be the same (if there are no identical characters). This is because, if `x * (x - 1) / 2` is odd, and the number of inversions within the selected range is odd, then the difference in inversions before and after is odd (if before is odd, after is even since `even + odd = odd`). If the number of inversions is even, then the difference in inversions before and after is also odd (if before is even, after is odd since `even + odd = odd`). Then, if `x * (x - 1) / 2` is even, and the number of inversions within the selected range is odd, the difference in inversions before and after is even (if before is odd, after is odd since `odd + odd = even`). And finally, if the number of inversions is even, the difference in inversions before in after is, once again, even (if before is even, after is even since `even + even = even`). This shows that the parity of number of inversions cannot change if reversals of any length are applied to both strings.
1685B|2000|AC|2|Understand that we can think of the problem as a greedy cost problem, where the cost of adding a `BA` can include removing any amount of `AB`, `A` or `B`. If we minimize the amount of `AB` removed when adding `d` `BA` (since `AB` can be turned into an `A` and a `B`), we can determine whether it is possible to produce the given string with the provided description.
388C|2000|DNF|0|N/A
1690G|2000|AC|4|Understand that simply simulating the problem using sets yields at most `n + m` removals and `m` additions for a final `O((N + M) * log2(N + M))` complexity.
1320C|2000|AC|4|Understand that we can sort all weapons in increasing order of `a` and all monsters in increasing order of `x`. Then, we can "try out" all weapons, considering more defeat-able monsters (at least by the `a > x` constraint) as `a` increases. When we consider a monster, we are effectively saying that all armor with `b > y` will profit by an additional `z`, where `y` and `z` are the `y` and `z` of the current monster. This can be accomplished using a range update data structure. Then, the maximum profit among all armor and be found (the data structure must also support some form of range query) and maximized after deducting the cost of the current weapon.
863E|2000|AC|2|Understand that, while the problem could be solved using range update range query, it can also be solved using prefix sums and coordinate compression, where all relevant points are compressed and prefix sums are used to get the number of overlaps at all compressed coordinates. If a point has only one overlap, the set that overlaps it is non-redundant.
1061D|2000|AC|2|Understand that we can simulate choosing between re-using an old TV or renting a new one for all TV shows using sets.
1183G|2000|AC|1|Understand that we can greedily find the maximum number of candies in the gift by processing the candies in non-increasing order of count and keeping a prefix minimum. If the current candy type has a count equal to the prefix minimum, set it to one lower. Then, once the counts are determined, they can be processed in non-increasing order, where a set can be used to keep track of the total `f` of all candy types with counts greater than or equal to the current count. This allows us to greedily remove the current greatest total `f` for the current count, leading to a maximum total `f`.
1190D|2000|AC|2|Understand that we can process the points in non-increasing order of `y` coordinate, and use combinatorics, provided the number of unique `x` coordinates of points with `y` coordinate greater than or equalt to the current `y` coordinate, to find the number of unique sets containing the current point. There is an edge case concerning points of the same `y` coordinate, but this can be handled by sorting such points by `x` coordinate and considering coordinates strictly after the last such point.
1619G|2000|AC|1|Understand that we can go through all `x` and `y` coordinates, sort them by their `y` and `x` coordinates, respectively, and use disjoint set union to unite mines that will explode together. Then, we can use binary search to find the minimum amount of time required to explode all mines.
1741F|2000|AC|4|Understand that the problem can be reformulated as two-dimensional range queries, querying among all `c[j] < c[i]` and all `c[j] > c[i]` as well as the intersections of segments. This problem can then be solved using sets and sorting.
1772F|2000|DNF|0|N/A
964E|2000|DNF|0|N/A