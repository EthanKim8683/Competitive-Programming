# Practice Problems Status
Problem|Rating|Correct cases|Attempts|Notes
-|-|-|-|-
723A|800|AC|1|The friends could meet at the position of the middle friend.
1399A|800|AC|1|By sorting the elements, we can remove the front repeatedly as long as the front satisfies the property stated in the problem.
432A|800|AC|2|Understand that, by sorting the students by number of participations, we can greedily put the first three (the ones with the most remaining participations) into a team. The number of such teams made this way that have at least `k` participations remaining is the answer.
490A|800|AC|1|Understand that we can greedily make teams consisting of `1` of each type until we run out of any of them.
1353B|800|AC|1|Understand that greedily swapping the smallest elements in `a` for the largest ones in `b` `k` times or until the swap no longer improves `a`'s sum yields the maximum possible sum of `a`.
1360B|800|AC|1|Understand that, by sorting the players by strength and assigning a prefix to `A` and the complementary suffix to `B`, we can minimize among all prefix/suffix pairs `|max(A) - min(B)|`, or more simply, the difference between any two adjacent elements in the sorted array.
1760A|800|AC|1|Understand that the problem can be simplified to sorting the numbers and taking the median.
1676B|800|AC|1|Understand that, as we cannot add or move candies, we have to reduce all quantities to that of the minimum box.
1742B|800|AC|1|Understand that, if the sorted array is not strictly increasing, it is impossible to make the array strictly increasing.
1669B|800|AC|1|While methods like histograms or multisets/maps might be more succint, they might not be as lightweight as sorting the elements and finding the lengths of all contiguous ranges of same elements.
1473A|800|AC|1|Understand that the sum of the smallest two elements of the array can be used to reduce the values of all other elements if needed using the operation given. If any minimized element still remains greater than `d`, it is not possible.
1618A|800|AC|1|Understand that the first two elements of the sorted array `b` will always be part of `a`, as all other elements are either the remaining element of `a`, or any combination of the three. To find the remaining element of `a`, we know the last element of `b` is the sum of all three elements in `a`, so we subtract the two known elements of `a` from this sum.
1760C|800|AC|1|An easy way to find strongest participant not including onself is to sort the participants by strength, compare all but the strongest with the strongest and then compare the strongest with the second strongest. Overall, it is a neat way to handle an edge case.
1692B|800|AC|1|Understand that in `ceil(c / 2) * 2` operations we can remove `c` duplicates.
1626A|800|AC|1|Understand that, printing all characters appearing twice two times in the same order, each pair will be the same distance away.
1629A|800|AC|1|Understand that running each software will always yield a net increase in RAM, provided that it can be run. Thus, it would be optimal to run the each software in increasing order until no software can be run.
1220A|800|AC|1|Understand that we can greedily make ones, then greedily make zeros because the cost of one one is one zero and the cost of one zero is one one.
1557A|800|AC|1|Understand that the maximum of `f(a) + f(b)` can be achieved by setting one subsequence to the maximum element alone (`a`), and the other to all remaining elements (`b`). This is because, in moving any element from `b` into `a`, we bring the sum closer to `f(a + b)`, the average of the original array.
1487A|800|AC|1|Understand that the only heroes that can never win are the heroes with the lowest levels, since they lose all their fights and have no chance to increase in level.
1792A|800|AC|1|Understand that it is only optimal to use the spell of the first type if there are two monsters with health equal to `1`. This is because the cost to kill each monster in this case is `0.5` spells. However, if the monster's health is greater than `1`, using the first type can only result in a number of castings greater than or equal to the health of said monster. In this case, we would use the spell of the second type as the cost is always `1`.
1705A|800|AC|1|Understand that sorting the people by height, and then comparing the heights of `i` and `i + n` for each `i` in range `[0, n)` allows is to check if its possible to arrange the group photo.
1398B|800|AC|1|Finding all contiguous lengths of `1`'s and then sorting them in non-increasing order of length allows us to greedily assign every odd indexed length to Alice.
1728A|800|AC|1|Understand that it can always be arranged that the color with the largest number of balls is the only one remaining.
1092B|800|AC|1|Understand that sorting the students by skill, then pairing every other student with their adjacent student ensures that either student is the closest cost-wise to the other.
1526A|800|AC|1|Understand that we can sort the array and then collate subarrays `[0, n)` and `[n, 2 * n)` such that every even element is strictly greater than to its neighbors and every odd element is stricty less than its neighbors.
1497A|800|AC|2|Understand that we can use multiset and iterate and erase in range `[0, n)` or until the next value to increase the MEX cannot be found. All remaining values are printed in any order, as they do not contribute to the MEX.
1552A|800|AC|1|Understand that the answer is just the number of indices such that differ between `s` and the sorted version of `s`.
1041A|800|AC|1|Understand that to get the minimum number of stolen computers, we can set `x` to the minimum remaining computer. This way, the minimum number of stolen computers is number of stolen computers between the minimum and maximum remaining computers.
1206A|800|AC|1|Understand that the sum of the maximum elements, `a` and `b`, in `A` and `B` cannot exist in either `A` nor `B` because `a + b` is greater than both maximums and there are no elements greater than the maximum.
1637A|800|AC|1|Understand that dynamic programming can be used to find the rightmost (maximum) element of a sorted prefix and the leftmost (minimum) element of a sorted suffix. If the maximum is greater than the minimum, it is possible to choose a `len` such that the final array is not in non-decreasing order.
1736A|800|AC|1|Understand that, if we are going to do the second operation, we only need to do it once, after we perform the first operation enough times. Thus, we can first find the number of operations required without doing the second operation at all, in case it is not necessary, and then the number of operations required if the we perform the second operation. The answer is the minimum of the two.
1646B|800|AC|1|As we do not need have more blue numbers than we need to, we can simply count one more blue number than red. We can also sort the array and make a prefix of the array blue and a suffix of the array red. This way, the sum of red is maximum and the sum of blue is minimum. Try all prefixes and suffixes to check if the property stated in the problem is possible.
1733A|800|AC|1|Understand that, since swaps can happen between any two indices equivalent modulo `k`, it is possible to rearrange all the maximums at indices modulo `k` into a prefix of window `k`. The sum of these maximums is the answer.
1720B|800|AC|1|Understand that we can take the two largest numbers and the two smallest numbers as both maximums and both minimums. Between them, a proper subsegment resulting in their sum can always be chosen.
1734A|800|AC|1|Understand that, by first sorting the array, the difference between each adjacent element is minimum. This way, using a window of three elements, we can minimize the difference between the minimum and maximum in the window among all windows.
1430B|800|AC|1|Understand that all but the maximum element can be added to the maximum. If we add them to the maximum in non-increasing order, we can maximize the maximum.
1656A|800|AC|1|Understand that `i` can be the index of the mininum element and `j` can be the maximum. This is true because all `a[k]` will be both greater than `a[i]` and less than `a[j]`, making `|a[i] - a[k]| + |a[k] - a[j]| = |a[i] - a[j]|` valid.
1445A|800|AC|1|Understand that pairing `a[i]` with `b[n - 1 - i]` will produce the smallest sum possible with respect to other pairs of `a[i]` and `b[j]`. If all sums are less than or equal to `x`, a rearrangement is possible.
1767B|800|AC|1|Understand that each movement results in a net increase in `a[0]`, so the smaller `a[i]` should be added to `a[0]` before the larger `a[i]`. Added them in non-decreasing order yields the maximum possible `a[0]`.
984A|800|AC|2|Understand that the result is the lowest median (if there are two).
1450A|800|AC|1|Understand that "trygub" contains inversions. By sorting the string, inversions are not possible and therefore, "trygub" cannot be a subsequence of the sorted string.
1688B|800|AC|2|Understand that the number of trailing zeros a token has is equal to the number of reductions required to make it odd. This way, we can sort the tokens by their trailing zero counts. If the smallest trailing zero count is `0`, we can fuse all tokens of non-zero trailing count with a token with a trailing count of `0`. If the smallest trailing count is not `0`, we can reduce it until it becomes odd, then fuse all other numbers with it.
1798A|800|AC|1|Understand that assigning the minimum of `a[i]` and `b[i]` to `a[i]` and the maximum of `a[i]` and `b[i]` to `b[i]` for all `i` ensures that no swap can be made to improve the state of `a` and `b`. If the property stated in the problem is still not satisfied, it is impossible.
1561A|800|AC|1|Understand that the constraints are small enough that we could simply run the sort and count the iterations until sorted.
1617A|800|AC|1|Understand that if `a`, `b` or `c` is not present in `s` or `t != "abc"`, the sorted `s` is the answer. Otherwise, print all `c` before all `b`.
551A|800|AC|1|Understand that a sorted copy of the array can be created and `upper_bound` can be used to find the number of elements strictly greater than each element.
609A|800|AC|1|Understand that we can first sort the USBs in non-increasing order, then greedily write to each USB until the `m` megabytes are entirely written.
1670A|800|AC|2|Understand that only a prefix of the array can be negative, otherwise the array cannot be sorted.
937A|800|AC|1|Since all numbers greater than or equal to a certain threshold greater than zero get awarded a diploma, the number of ways to award diplomas is equal to the number of unique non-zero scores.
1305A|800|AC|1|The problem could be seen as this: take the two maximums from `a` and `b`, `x` and `y`. Their sum will never equal the sum of any other pair from `a` and `b` because all `a[i]` and all `b[i]` are distinct, and `x + y` is greater than all other pairwise sums. Do this `n` times to find the answer.
1738A|800|AC|1|Understand that, unless the count of both types of skills are equal, the top `m` of each type are represented twice. If both types of skills have the same count, `m` of one and `m - 1` of either types are represented twice.
1740B|800|AC|1|Understand that, if we sort the slices of cheese in non-decreasing order, the total perimeter is equal to the maximum height multiplied by the total width. With this, we can binary search for maximum height against total width to minimize their sum.
992A|800|AC|1|Understand that the number of seconds required is the number of unique non-zero numbers. This is because all elements of the same value will be handled in the same second, and all zeros don't need to be accounted for.
169A|800|AC|1|Understand that, after sorting the chores, the chore at index `b - 1` is the minimum value of `x` and the chore at index `b` is one greater than the maximum value of `x`.
291A|800|AC|1|Understand that a map can keep track of the id of each call Polycarpus' secretaries are in, as well as the number of secretaries in the call. The answer is the number of calls with exactly two secretaries in them, and Polycarpus has a mistake in the records if there exists a call with greater than two secretaries in it.
769A|800|AC|1|Since Igor joins `x` groups on either side of his year, the answer is the median of the years of the groups Igor joined.
160A|900|AC|1|Understand that we can greedily collect the coins with the greatest values until the total is greater than the remaining.
405A|900|AC|1|Understand that switching the gravity is equivalent to sorting the columns.
1535B|900|AC|1|Understand that the only way reordering the array can increase the number of good indices is if we can make `gcd(a[i], 2 * a[j]) > 1`. We can do this by sorting by parity, where even elements come first, then odd.
768A|900|AC|1|Understand that we can use a sorted map and remove the least and greatest entries. The remaining sum is the number of stewards with other stewards of value strictly greater and strictly less than their value.
1420A|900|AC|1|Understand that the number of swaps required is equal to the number of inversions in the array. If there are greater than `n * (n - 1) / 2 - 1` inversions, Wheatley won't sort the array. There are greater than `n * (n - 1) / 2 - 1` when the array is strictly decreasing.
1272A|900|AC|1|Understand that, in order to reduce pairwise distance, the leftmost and rightmost friend should be moved closer to each other. Moving the middle friend does not make any difference from the total.
1216B|900|AC|1|Understand that it is optimal to shoot the more durable cans first, since the factor in which their durability is multiplied is less.
807A|900|AC|1|If there are any rating differences, the round was rated. Otherwise, if the ratings are in non-increasing order, it is impossible to tell.
1665B|900|AC|1|Understand that the count of each value could be taken. The value with the greatest count can be set as the final value of all the elements of the array. Also understand that cloning, then swapping yields a `log2(N)` solution worst case.
1480B|900|DNF|0|N/A
1427A|900|AC|1|Understand that, if the sum of the numbers is greater than `0`, starting with the positive numbers, then ending with the negative numbers ensures all prefixes has positive (non-zero) sum. If the sum is negative, negative then positive ensures all prefixes have negative sum. Finally, if the sum of the numbers is equal to `0`, it is impossible to arrange the numbers such that all prefix sums are non-zero because the `n`th prefix has sum `0`.
1144B|900|AC|1|Understand that we can only remove at most `min(|E|, |O|) + 1` elements from both the set of even numbers `E` and odd numbers `O`, of course limited by their respective sizes.
1248B|900|AC|1|Understand that we want to invest as large a distance in one dimension as possible and as small a distance in the other. This is because, as `theta` approaches `PI / 4` (away from the axes), the sum of the `x` and `y` components of the unit vector are greater than the sum of the components when the unit vector is aligned with one of the axes. With this, we want to minimize `theta`.
1668B|900|AC|1|Understand that ordering the people by non-decreasing order of distance ensures that, between any adjacent pair of people, the distance wasted is minimum.
572A|900|AC|1|Understand that we can choose the `k` smallest elements from `A` and the `m` largest elements from `B` and if the largest element from the selected portion of `A` is less than the smallest element in the selected portion of `B`, a selection is possible.
1093B|900|AC|1|Understand that sorting the characters in the string makes the string as assymetric as possible, as elements on the left will be less than those on the right if possible. From here, if the resulting string is still a palindrome, a rearrangement is impossible.
1584C|900|AC|1|Understand that sorting both `a` and `b` and adding one to `a[i]` for each `i` where `a[i] != b[i]` will yield the solution if possible.
16B|900|AC|1|Understand that it is optimal to get the matchboxes with the most matches first.
1106C|900|AC|1|Understand that the groups should be as small as possible, since for every number `x` added to a group of sum `y`, an additional `2 * x + y + x * x` is added to the total. In addition, to minimize the sum of each group, the largest number should be paired with the smallest number repeatedly until no more numbers are available. This is because, for each number `a`, if paired with a smaller number `b`, an even larger number `c`, otherwise paired with `b`, would get paired with a larger number, which is not optimal. If paired with a larger number `d`, `a` could be paired with a smaller, more optimal, number.
1198B|1600|AC|1|Understand that updates can be handled in reverse, such that only the last single update is handled at each index. In addition, said update is also maximized with the running range update maximum.
1198A|1600|AC|3|Understand that we can calculate the maximum number of unique values that fit within the disk, then use a sliding window to find the maximum number of unchanged elements possible.
1461D|1600|DNF|0|N/A
1140C|1600|AC|4|Understand that sorting the songs by beauty, then querying the `k - 1` longest remaining songs (not including the current one) to find the total length suffices.
231C|1600|AC|1|Understand that after sorting the array, we can, for each element in the array, query how many elements less than it can be made equal to it in less than or equal to `k` operations with binary search.
1151D|1600|AC|2|Understand that the dissatisfaction `a * j + b * (n - 1 - j)` can be reformulated as `b * (n - 1) - (b - a) * j`. This means we can sort each `(b - a)` in increasing order and greedily subtract each one by their resulting index.
1566D2|1600|AC|1|Understand that it is optimal to put smaller indices on the right and larger ones on the left. Also note that the people enter the hall in non-decreasing order of sight level. This means that the only freedom of order that we have is how groups people of equal sight level are ordered. Obviously, through our first observation, they should be ordered in non-increasing order. However, if such a group spans multiple rows, it is possible for one to occupy a suffix of a row, in which case it would be optimal for the suffix to be as small as possible. With this, we can initially sort each group in non-decreasing order to ensure that such a suffix would be small, then sort them within each row in non-increasing order.
1077D|1600|AC|1|Understand that binary search can be used to find the maximum number of cuts that can be made, which can then be used to greedily produce an answer.
1665C|1600|AC|4|Understand that each node with children should have at least one child be injected. Since only one injection may happen each second, it would be optimal to inject the children of nodes with the most children first, as spreading would take care of as many nodes as possible that way. Afterwards, binary search can be used to determine how many of the remaining nodes should be injected or spread to.
1165E|1600|AC|1|Understand that to achieve a minimum sum of products of two arrays, we multiply the `i`th largest in one array with the `i`th smallest in the other for all `i`. To modify this to solve our problem, we can multiply the contribution of each index `i` to the sum with `a[i]` prior to sorting.
1029C|1600|AC|1|Understand that coordinate compression and prefix sums can be used to find the size of each subset of intersections, as well as how many segments overlap it. Then, prefix sums can be used again to find the cost of removing a segment.
350C|1600|AC|2|Understand that destroying the bombs in increasing order of absolute `x` (and increasing order of absolute `y` for equal `x`) ensures that the robot would not run into another bomb in the process of picking up and disarming a bomb.
493C|1600|AC|1|Understand that, after sorting both `a_arr` and `b_arr`, we can use two pointers to find the number of `2` point shots scored by either team provided a sorted array of all relevant `d` (at most `n + m` unique values).
1781C|1600|AC|1|Understand that we can brute force for the total number of unique characters in the string `t`, since there are at most `26` unique characters. For each unique character count `i`, we choose the `i` most common characters in string `t`, since they would require the least number of characters to be replaced to equal them.
525C|1600|AC|2|Understand that we can sort the sticks by length, an greedily pair valid pairs of equal length sticks (possibly after an operation) to form rectangles.
1082C|1600|AC|4|Understand that we can sort the subjects in non-increasing order of the number of candidates who specialize in them. Then we can complete search for all quantities of unique subjects, and then the number of candidates per subject within each of them. To get the maximum sum of skill levels for each number of candidates, we can take the prefix sums at each number of candidates and add it to the total cost of said number of candidates if the prefix is non-negative. Maximizing along the complete search results in the optimal answer.
599C|1600|AC|1|Understand that it is possible to find the closest index `j` for each index `i` such that the swap would result in the position of `h[i]`. All swaps that "tangle" (their ranges intersect) must form a block since their necessary swaps interfere with each other. Using this, we can find how many groups of swaps do *not* tangle, resulting in the answer.
822C|1600|AC|1|Understand that for all departure dates, we can minimize the cost of the sum of the voucher and any other voucher whose arrival date precedes the departure. We can do this by complete searching among all dates and keeping a running minimum of the cost of all durations such that their arrival is before the current date.
1028C|1600|AC|4|Understand that, if we first search for candidate `x` values using prefix sums along just the `x` axis, there are at most `3` candidates to check the `y` values for.
1137A|1600|AC|1|Understand that the minimum `x` for each intersection `(i, j)`, provided arrays of unique values for each row `i` and column `j`, `R[i]` and `C[j]`, respectively, is equal to `max(|k ∈ R[i] | R[i][k] < R[i][j]|, |k ∈ C[j] | C[j][k] < C[j][i]|) + max(|k ∈ R[i] | R[i][k] >= R[i][j]|, |k ∈ C[j] | C[j][k] >= C[j][i]|)`. This is because the intersection value `a[i][j]` serves as a fixed point in both the set of values in row `i` and column `j`, meaning that all values less than `a[i][j]` in row `i` (call it `X`) must each have a unique value and same goes for the column `j` (call it `Y`). This could be represented as the maximum of the cardinality of both sets. In similar vain, we can apply the same logic to all values greater than or equal to `a[i][j]`.
593B|1600|AC|1|Understand that if the order of the lines right after `x1` and just before `x2` are different, there must have been an intersection in the interval `(x1, x2)`.
858D|1600|AC|1|Understand that coordinate compression can compress the substrings. For each possible substring, we can determine if it corresponds to a singular phone number, and if it does, we can minimize the result for that phone number with the length of the substring.
830B|1600|AC|1|Understand that each contiguous group of same-number cards should be sorted with respect to the last visited index. A point update range query data structure like Fenwick tree can be used to simulate removing and cycling through cards to reach a minimum card.
430A|1600|AC|1|Understand that if segments within segment `[l, r]` have `|r - b| <= 1`, segment `[l, r]` satisfies the property as well. We can ensure this by dividing the ranges into subranges such that each subrange represents a unique subset of segment overlaps. Then, we can divide the subrange into red and blue such that `r - b <= 1` holds. Finally, each subrange now has an `r - b` of either `0` or `1`, we can alternate between `1` and `-1` for each `1` so that now, all segments have absolute difference less than or equal to `1`.
175C|1600|AC|1|Understand that each factor could be treated as multiplying the count of each figure destroyed by said factor, and since we want to destroy more figures of higher cost, we can order the figures in increasing order of cost.
1346C|1600|DNF|0|N/A
1474C|1700|AC|2|Understand that `x` must always be the maximum remaining value, and if it can't be, then the destruction is impossible.
1336B|1700|AC|2|Understand that, for each `r`, we can find the closest `g` such that `g >= r`, then, find the `b` closest to `floor(r + (g - r) / 2)`, since that would yield the optimal `b` given known `r` and `g`. We can repeat this for all permutations of `r`, `g` and `b` and minimize among all of them.
1393C|1700|AC|2|Understand that the problem can be simplified to spacing out the patty-cakes corresponding to the mode filling. For each patty-cake, we can simply append it to the spacing and loop in case the spacing spills over the mode minus one (since we only need spacing *in between* each patty-cake of the mode). This works because these patty-cakes will never overlap itself, that is, unless the count is greater than the mode minus one, in which case we let the remaining one go after the spaced patty-cakes, or clamp it.
559B|1700|AC|1|Understand that if we sort both strings such that, in each sorting operation, if a string can be split into halves, we swap them if the left half is lexicographically greater than the right half, their equality is the answer.
1684D|1700|AC|2|Understand that the reduction in damage from the total is equal to, for all `i` in `inds`, `a[inds[i]] - (inds[i] - i)`, where `inds` is an array of indices, sorted in decreasing order, of length at most `k`. If we separate the terms, note that the total `i` is only dependent on the length of `inds`, and each `inds[i]` can be chosen independently. With this, we subtract `j` from each `a[j]` and choose the `t` greatest for each `t` in range `[0, k]` and maximize for all `t`.
382C|1700|AC|2|Understand that we can solve individually for every number of unique adjacent differences in the sorted array.
1779D|1700|AC|2|Understand that stacks can be used to find the ranges that need to be cut with a certain razor. Then a multiset can be used to determine if there are remaining razors of that type. The answer is whether or not the entire haircut can be completed without running out of the requisite razors.
732D|1700|AC|3|Understand that we can use a segment tree to determine the latest one can start studying to pass all `m` exams. If the latest (going left to right) is greater than `0` and there is enough time to study for and take all exams, the answer can be minimized with the current index.
439D|1700|AC|1|Understand that we can use `upper_bound` and `lower_bound` on the sorted versions of arrays `a` and `b` to find how many `i` such that `a[i] <= x` and `j` such that `b[j] >= x` for `a` and `b` respectively given an `x`. This can then be used along with prefix sums to find the cost of clipping the minimums of `a` and the maximums of `b` along such `x`, the sum of which can be minimized among all `x` in `a` and `b`.
1148C|1700|AC|2|Understand that it is possible to get any element to any position by swapping with either end of the array (whichever possible) as an intermediary step.
1792D|1700|AC|1|Understand that the problem is equivalent to finding the longest common prefix of permutation `i` and the inverse of any permutation `j` among all `j` for each `i`.
1310A|1700|AC|1|Understand that a set can be used to find the next available number of publications for a given `i` with `a[i]` publications. In order to get the optimal answer, we must first sort in non-increasing order of `t[i]`, since more expensive categories should require fewer additions, and then find the next available number of publications for each category, adding to the total each time.
567D|1700|AC|2|Understand that we can assume all shots result in misses, in which case, all remaining cells can be treated as candidates for ships. With this, we can, for each contiguous range of unknown cells, calculate the number of ships that could fit in this range: `c = (l + 1) / (a + 1)`, where `c` is the number of ships, `l` is the length of the range and `a` is the provided `a`. Now, to update the counts of each contiguous range, we can keep track of the bounds of each range using a sorted set, and only update the relevant ranges for each `x`.
1468D|1700|AC|1|Understand that the robber should, firstly, never move towards the guard. Secondly, the robber should always drop all their firecrackers as early as possible, such that the delay until explosion and the robber's fleeing coincide. With this, we can greedily choose firecrackers that can be exploded within the time the robber has.
827A|1700|AC|3|Understand that, at each index, we can determine the string `t` that can predict the string `s` at the latest possible index. For all unknown indices between known indices, we substitute with 'a', the lexicographically smallest character possible.
978G|1700|AC|1|Understand that we can use a sorted set to, for each day, keep track of the most "urgent" exam, the exam that will be administered the soonest, such that the questions have been published already.
729C|1700|AC|4|Understand that the time taken to travel a given distance `d` on a full tank `v` is equal to `2 * d - 1 * min(v - d, d)`, assuming `v >= d`. This is because, if we drive in normal mode the entire distance `d`, it would take `2 * d` minutes, but we would have `v - d` liters of gas left over. We can use these liters of gas to convert normal mode kilometers into accelerated mode kilometers, the cost of which is `1` extra liter, for a decrease in time of `1` minute. Using all `v - d` extra liters, we can decrease the time taken by `1 * min(v - d, d)` minutes, since we cannot drive in accelerated mode on more than `d` kilometers. Using binary search, we can find the prefix and suffix of the sorted array of all distances such that `d` and `v - d` equal the minimum respectively, and solve for them to produce the total time for all distances until the cinema.
631C|1700|AC|1|Understand that we can iterate through all indices where an operation is applied and apply the latest operation, which can be found using a stack. Then, a set can be used to remove either the least or greatest remaining element, depending on the current sorting order.
761D|1700|AC|1|Understand that we can find `b` for indices in increasing order of their corresponding `p`, where each `b` must result in a `c` greater than the last.
895B|1700|AC|3|Understand that, for each `a`, we can find the range of values that satisfy the stated property. Then, we can use `lower_bound` and `upper_bound` on the sorted `a_arr` to find how many `a` lie within said range.
160C|1700|AC|7|Understand that we can treat each pair as a two digit number, where each tens digit can have a different amount of ones.
596C|1700|AC|4|Understand that no `y - x` should occur more than once in a set `S` such that all members of the set have equal `y + x`. This means that we can sort the points by their `y + x` and greedily assign the earliest remaining `w` equivalent to their `y - x`. Then, we can check if the solution is valid and, if so, print the assignment.
1056C|1700|AC|1|Understand that we first go through all hero pairs, since, after choosing the first hero in such a pair, the opponent is forced to choose the second hero, returning the move back to the player. Then, the remaining heroes should be chosen in non-increasing order of power.
925B|1700|AC|5|Understand that, after sorting the array, the leftmost element of a subarray is always the minimum of said subarray. This allows us to do a complete search, starting with the greatest element of the array towards the smallest, for two adjacent subarrays of resource units that satisfy the requirements.
161B|1700|AC|2|Understand that we want as many single-stool carts as possible, with the carts chosen being as high as possible. We can do this by greedily distributing stools to the `k` carts and filling the remaining carts with pens. If there are none remaining, fill the least expensive cart with the pens.
131E|1700|AC|1|Understand that, for each queen, we can add the minor diagonal position, major diagonal position, row and column to vectors corresponding to the queen's major diagonal position, minor diagonal position, column and row, respectively. This allows each queen to query the existence of another queen higher or lower on the minor diagonal, major diagonal, row or column in that order.
81C|1700|AC|1|Understand that, if `a < b`, each unit of each score is worth more in Safety Studies than in PE, and so the `a` greatest scores should be attributed to Safety Studies. If `a > b`, each unit is worth more in PE, so the `b` greatest scores go to PE. If `a == b`, each unit is worth the same in either subject, so the least significant `b` scores are assigned to PE.
216D|1700|AC|1|Understand that `upper_bound` and `lower_bound` on the sorted attachment points of the left and right sectors can be used to find the number of attachment points within the left and right side of a cell respectively.
159E|1700|AC|1|Understand that we can process the colors in decreasing order of count, keeping track of the maximum prefix sum by count after each color. Then, we can maximize the sum of the current prefix sum and a previous maximal prefix sum for all colors to get the optimal answer.
1211C|1700|DNF|0|N/A
1619D|1800|AC|1|Understand that the problem can be reformulated as, at least one store must have gifts for at least two friends. With this, we can, first, find the minimum among all maximum friends' maximum joys `x`. Then, for each store, find the minimum of the two maximum joys `y`. The result is the maximum of `min(x, y)` for all stores.
1156B|1800|AC|2|Understand that, if there are at least `4` unique characters, the characters can be greedily ordered such that no two neighbors are neighboring in the alphabet with each other. Otherwise, we can brute force for the solution using `next_permutation`.
1552C|1800|AC|1|Understand that the circle can be flattened into a line containing coordinates `[0, 2 * n)`. On this line, two chords in the initial circle intersect if their corresponding ranges on the line intersect, but do not contain one another. With this in mind, it would be optimal to pair the first half of the remaining `2 * (n - k)` points with the second half as that would maximize the number of aforementioned intersections. Finally, we can use a point update range query data structure to count the intersections.
1705D|1800|AC|1|Understand that it is possible to reach a lightbulb configuration equivalent to that of `t` as long as the number of contiguous ranges of lightbulbs turned on in both `s` and `t` are the same and both strings have lightbulbs of the same state on each end. Each contiguous range in `s` can be mapped to a range in `t` of the same index, and can be reached, if all previous ranges have been matched, in `abs(l1 - l2) + abs(r1 - r2)` operations, where `l1`, `r1`, `l2` and `r2` are the left and right bounds of the ranges in strings `s` and `t` respectively, since each operation can be thought of extending or reducing a range by `1` lightbulb.
1721D|1800|AC|4|Understand that a breadth-first search can be used to check, for each bit `i` in decreasing order of significance, if it is possible to achieve a result with `i`. If it is, sort the current subarray in opposite order with respect to bit `i`, and queue the subarrays corresponding to the `0` and `1` valued ranges after the sort. Otherwise, skip the current bit and re-queue the current subarray.
1154E|1800|AC|1|Understand that we can use a sorted set to keep track of the remaining players.
1148D|1800|AC|1|Understand that a sequence of type 1 can only exist if all `i` contained in it satisfies `a[i] < b[i]`. Likewise, type 2 can only exist if all `i` satisfies `a[i] > b[i]`. Now, for a type 1 sequence, if the `i` were arranged in decreasing order of `b`, their corresponding `a` cannot be greater than the previous `b`. For type 2, in increasing order of `a`, the corresponding `b` cannot be greater than the following `a`. Sorting in this way guarantees an optimal solution. 
1801B|1800|AC|4|Understand that processing the departments in decreasing order of price for the first friend, then in increasing order of price for the second friend, in this order of significance, allows the problem to be solved for every maximum first price by keeping track of the minimum maximum second price required to achieve said first price. This works because along with the minimum maximum second price, any department whose first price is less than the current maximum first price can be used to buy a gift for the second friend. So to solve at each maximum first price, we can simply take the minimum of 1. the minimum maximum second price, 2. the maximum of the minimum maximum second price and the greatest second price less than or equal to the current maximum first price or 3. the maximum of the minimum maximum second proce and the least second price greater than or equal to the current maximum proce.
1249D2|1800|AC|1|Understand that we can maintain a satisfactory solution to the subproblem containing all segments before the current one. Now it is a matter of modifying the solution to the previous subproblem. Note that, if including the current segment displaces any included segments in the previous subproblem, the cost can only be greater than or equal to the cost of excluding the current segment. Thus, simply including the current segment if there is space produces an optimal solution.
1119D|1800|AC|1|Understand that, first, it is only the number of frets covered by each query's range that affects the number of different pitches, as the left bound will simply shift the pitches and do not affect how they interact. Secondly, the number of frets between strings represents the number of unique pitches achievable before overlap. Sorting can be used to solve each query provided these two observations.
913D|1800|AC|2|Understand that we can binary search for the total number of problems completed to get the optimal solution. Solutions can be checked using a greedy algorithm sorting the time it takes for each problem.
1077E|1800|AC|1|Understand that we are essentially trying to fit an exponential curve underneath the sorted array of topic counts. For this, we can align the exponential curve ending at exponential `i` as far right as possible and determine the maximum initial problem count for all `i``.
922D|1800|AC|1|Understand that the number of "sh" subsequences introduced between a pair of any two `t` is equal to `s * h`, where `s` is the number of 's' characters in the leftmost `t` and `h` is the number of 'h' characters in the rightmost `t`. Using this formula, we can determine the ordering of the strings for any pair of `t`: if `s1 * h2 < s2 * h1`, where `s1` and `s2` are the number of 's' characters in the leftmost `t` and the rightmost `t` respectively and `h1` and `h1` are the number of 'h' characters in the leftmost and rightmost `t` respsectively, then the `t` should be swapped. Rearranging the inequality (`s1 / h1 < s2 / h2`) shows that each `t` is independent, allowing us to sort the entire array of `t` to produce an optimal solution.
1282C|1800|AC|1|Understand that we can simply find and maximize among all the maximum number of problems solvable before each deadline and by the end of the exam.
1005E1|1800|AC|1|Understand that the number of ranges is a matter of choosing left and right bounds of each range. A left and right bound are valid if `a - b <= 1`, where `a` is the number of values greater than `m` within the range and `b` is the number of values less than `m` within the range. Now, we can store, for each left and right index `i`, `a - b` between the index of `m` in `p` and `i`, and simply look up the number of right indices for each left index such that their total `a - b` is less than or equal to `1`.
612D|1800|AC|3|Understand that we can use sweep line to find all segments containing only satisfied points.
652D|1800|AC|1|Understand that processing in increasing order of the right bound of each segment and querying the number of left bounds of already visited greater than the current segment's left bound using a point update range query data structure yields the number of nested segments for each segment.
492D|1800|AC|1|Understand that binary search can be used to find the minimum number of seconds (multiplied by `lcm(x, y)`) `s` to defeat each monster. From there, we can use the remainders of `s % x` and `s % y` to determine if Vanya, Vova or Both made the last hit.
794C|1800|AC|3|Understand that for each player, if placing their most optimal character as close to the front as possible is better than placing their least optimal character as close to the back as possible, they should place their most optimal character as close to the front as possible, and vice versa.
652C|1800|AC|1|Understand that we can keep a multiset of right bounds of all foe pairs. For each index `i`, we can find the smallest right bound such that the corresponding left bound is strictly less than `i` (this can be achieved by removing right bounds from the multiset when their left bound is visited). Then, these range lengths can be accumulated to produce the final result.
853B|1800|AC|1|Understand that we can, for each day `i`, calculate the minimum cost of all jurors arriving in Metropolis before or on `i` as well as the minimum cost of all jurors leaving Metropolis after or on `i`. Using this, we can try every window starting at `i` of size `k` such that the jurors arrive before or on `i` and leave after `i + k`.
432C|1800|AC|6|Understand that, by Goldbach's conjecture, all even numbers can be represented as the sum of at most two primes. Meaning that the cost of all even distance swaps can be represented as the combination of two swaps of one less than a prime. With this, all odd numbers can then be represented as the combination of at most three swaps, as one swap could be of length `1` and cost `2` (which is prime) and the other two travels the remaining even distance. This results in at most `5` swaps per index.
433C|1800|AC|2|Understand that for each page `x` we can find a page `y` such that the total number of page turns is minimal. To find such `y`, we can simply take the median of all pages turned to or from page `x`, as any page before or after the median would include the cost of the median as well as the other pages (which would cancel out) and therefore be greater than if the median was selected. The total number of page turns for each `x`-`y` pair can be minimized among all `x`.
141C|1800|AC|1|Understand that by sorting the people in increasing order of number `a` will always produce an optimal solution if it exists. This is because `a` represents a lower bound to the number of people ahead of them, taller or not (this can also be used to verify if a solution exists). Finally, a vector can be used to determine the actual heights of each person. Since just the heights of people in front of each person is relevant to the solution, one can simply insert at index `a` and forget about it.
140D|1800|AC|1|Understand that, in order to solve the maximum number of problems, we can greedily select the problems that take the least time until no more problems can be chosen. Then, to order the problems, note that any problem solved before the New Year will have `0` cost, since Gennady can distract from the problem he is solving to submit solutions, and any problem solved after the New Year will have cost proportional to the time it is solved after the New Year. With this, we can construct an argument that the optimal solution has the problems solved in increasing order of time consumption: for any two problems `l` and `r` (in increasing order of index), if `l` takes longer to solve than `r`, swapping them will always improve the cost. This is because all problems solved before `l` and all problems solved after `r` won't get affected by the swap, but all problems between `l` and `r` will have reduced costs, since `l` is replaced with `r`, which can be solved sooner. Meanwhile `l` and `r`'s costs are swapped, for a net cost of `0`.
724C|1800|AC|1|Understand that the next intersection can be found by finding the minimum distance to a wall given the current velocity. The velocity can be flipped based on the direction of the wall being collided with (vertical or horizontal).
222C|1800|AC|2|Understand that fast factorization preprocessing can be used to quickly factorize all `a` and `b`. Then all factors shared between the `a` and `b` arrays are removed (quantity matters). The factors are then multiplied together (in order of factorizing, since the existing order already fits) to ensure that the output fits as required.
252B|1800|AC|6|Understand that it is possible to unsort all arrays of length greater than or equal to `4` and some arrays of length equal to `3`. Using this, we can hardcode all solutions to compressed subarrays of length `3` and `4`.
83B|1800|AC|2|Understand that by processing each number of visits `a` in increasing order we can repeatedly "shave off" the number of remaining visits for all unprocessed/processing `a` by the current `a`, and with it, `n * a` from `k`, where `a` is the current `a` and `n` is the number of unprocessed/processing `a`. This happens until the remaining `k` is too small, when the amount shaved off will equal `k / n`, where `n` is the number of unprocessed/processing `a` and the remaining `k` can be used to brute force the remaining visits, as `k <= n`.
370C|1800|DNF|0|N/A
847K|1800|DNF|0|N/A
1375D|1900|DNF|0|N/A
1444B|1900|DNF|0|N/A
1342D|1900|DNF|0|N/A
