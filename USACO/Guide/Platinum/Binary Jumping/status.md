# Practice Problems Status
Problem|Rating|Correct cases|Attempts|Notes
-|-|-|-|-
Company Queries I|Easy|AC|1|Basic binary jumping. Each node contains an array of power of two-th ancestors. Queries are answered by going to the `i`th (`0`-indexed) ancestor of the current node for every positive bit, starting with the least significant bit.
Planets Queries I|Easy|AC|2|Binary jumping, except not on a tree, rather a functional graph. Similar implementation as above.
Planets Queries II|Normal|AC|2|Understand that Floyd's algorithm can be used to find cycles, their length, as well as distance to the closest cycle in a functional graph. Each query can then be approximately answered using the distances calculated, with binary lifting to check it.
Cyclic Array|Normal|AC|1|Represent the upper bound `j` (non-inclusive) of each range beginning at each index `i` such that the sum of range `[i, j)` is less than or equal to `k` as the ancestor of the index. Using binary lifting, we can find the endpoint of a range beginning at `i` after any amount of consecutive subarrays. With this, we can binary search for the minimum number of consecutive subarrays before the combined ranges completely wrap around the cyclic array. Then the result could be calculated by minimizing this amount for every starting index.
2010 - Frog|Normal|AC|7|Understand that a `p[j]` can be found for every `p[i]` using binary search, which can then be used for binary lifting. However, naive `log2(M)` would not work, as it exceeds the memory limit. Thus, Floyd's algorithm must be used to determine each node's distance to a cycle and each cycle's length, such that `log2(N)` can be used.
Lynyrd Skynyrd|Normal|AC|1|Understand that, at each index `i`, binary lifting can be used to find the minimum index `j` such that a cyclic permutation starts with `a[i]` and ends with `a[j]`. This can be combined with a range minimum query data structure, such as a sparse table, to find whether any subsequence beginning within the provided range also ends within the range.
2019 - Valley|Normal|AC|2|Understand that binary lifting, along with a second value keeping the minimum distance to a shop such that the corresponding node is reachable can be used to solve each query. Note that the minimum distance is tricky to keep track of naively, and thus can be represented as the distance to root (`E`) minus the minimum distance to a shop child. This allows the value to be maximimized and still offer consistent results to all children by subtracting this value from the child's distance to root. As for queries that result in escaping, Euler tour can be used to determine if the blocked edge `i` blocks an ancestor of the target node `r`.
2017 - Toll|Normal|AC|1|Understand that, the structure of the directed graph could be represented as that of a straight path with subgroups of size at most `k`. Binary lifting to find the minimum path from one node in a subgroup to another in another subgroup by keeping track of the minimum distance travelled by the lift. Using this, combined with the fact that the number of edges between two nodes `a` and `b` such that `floor(a / k) <= floor(b / k)` is `b / k - a / k`, we can use binary lifting to find the minimum distance between said nodes. Note the similarities to segment tree- and possible dynamic programming applications with it.
262144|Hard|AC|1|Understand that each possible value at each index can be achieved by only joining with values at lower indices, leaving the immediate upper index for other upper indices to join with it adjacently. With this, binary lifting, or at least the process in which it is built, can be used to join values and ultimately, find the largest value possible.
2015 - Editor|Very Hard|AC|1|Understand that the "proto-ancestor", or the operation a node undoes, never changes past initialization. This is because, for a proto-ancestor to change, the proto-ancestor must be undone before the current node becomes active again, such that it must re-pick a nearest node to undo. However, this is impossible: call the current node `a`, and its proto-ancestor `b`. To first undo node `a`, we need a node `c` where `c > a`. Then, to undo node `b`, the proto-ancestor, we need a node `d` such that `c >= d > b`. Now, to finally re-activate node `a`, a node `e` must be added where `e > c`. However, node `e` would instead undo node `d` first because node `d` is closer and `e > d`. Following this logic, the node the undone node undoes also always remains the same, call this node the "ancestor". The ancestor of an undo operation at index `i` is, for the rightmost index `j` where `level[j] < level[i] && j < i`, the rightmost index `k` where `level[k] < level[i] && k < j`. And, for the sake of monotonicity along indices, ancestor of an edit operation at index `i` is the rightmost index `j` where `level[j] < level[i] && j < i`. Note that every ancestor is of a lesser level than its children, this is because, for every node `a`, node `b` must satisfy `b > a` in order to undo `a`, so the ancestor of each node could be found using binary lifting. In addition, the same logic could be used to find the greatest index of an active edit, solving the problem.
Max Flow|Easy|AC|1|Understand that LCA can be used to find the highest point of a path between two nodes `s` and `t`, and prefix sums can be used to find the number of paths passing through any given node.
Running Away From the Barn|Normal|AC|1|Understand that all nodes from the highest reachable node from the current node to the current node can reach said current node. This can be found using binary lifting.
Tree Boxes|Hard|AC|1|Understand that, by placing every node on a diagonal-like pattern facing their parent, it is possible to recursively position each node such that a box only captures a node and its ancestors. LCA with binary lifting can then be used to find the corner nodes of each box.
New Barns|Hard|AC|1|Understand that the at most one endpoint of the diameter of a tree can change per addition of node. Also note that no node can have a maximum distance further than its maximum distance to either endpoint of the current diameter (otherwise, the endpoints aren't accurate to the diameter). With this, we only need to do two comparisons per query, and one update per update, both in logarithmic time thanks to LCA with binary lifting.
Gathering|Hard|AC|1|Understand  that, assuming we root the tree at a node `x`, for every pair `a` and `b`, `a` must not be an ancestor of `b`. This is because `a` leaving would cause `a`'s now separated subtree to eventually end with a friendless cow. Using this, we can effectively say each pair divides the tree in half: the half where, for each tree rooted in a node of said half, `a` is reached before `b`, and the half where `a` is *not* reached before `b`. Now, as stated before, if `a` is an ancestor of `b`, the tree is invalid, and thus, all nodes of the half where `a` is reached before `b` cannot be the last to leave. Use LCA to divide the halves for each pair, and if there is a cycle in the pairs, none of the nodes can be the last cow.
Exercise|Very Hard|AC|1|Understand that each non-standard trail, from before or at its LCA, will always be invalid because it would require fields to be revisited in order to form a cycle. With this, we could define valid ranges for each non-standard trail: with `c` as the LCA of trail endpoints `a` and `b`, the ranges are `[a, c)` and `[a, b)`. For any pair of trails that have overlapping ranges, they can produce a good route. We can use DP and PIE to find this answer.
Sloth Naptime|Easy|AC|2|For each move query, we can find the LCA using binary lifting and simulate movement from `a` towards the LCA and then back down to `b` based on the number of moves `c`.
Duff in the Army|Normal|AC|4|Understand that sets can be kept track just as ancestors are in binary lifting. In this case, store the minimum `ID`s along the path from the current node `a` to its `2 ** i`th ancestor for a given `i`. Note that sets don't need to be larger than `A`, so the final complexity is just `O((N + Q) * log(N) * A * log(A))`.
2017 - Railway|Normal|AC|1|Understand that small-to-large merging can be used with sets containing the indices of the ministers who believe the current node (and thereby parent edge) should be connected. This can then be merged towards the root, where, at the LCA of all the neighborhoods suggested by any given minister `i`, `i` can be removed from the set so as to not be counted outside of the relevant area.
Root LCA Queries|Normal|AC|1|Understand that, `a`, `b` and `c` divide the tree into `3` parts: the subtrees that reach `a` first, the subtrees that reach `b` first and the subtrees that reach `c` first. To find this, we can use LCA, but more specificially, we can find the nodes closest but not equal to `c` from `a` and `b`, as the subtrees up to those nodes all reach `a` or `b` first. Using this, we can subtract those subtrees from the total `n` to get the answer.
Two Paths|Normal|AC|1|Understand that each 2-path can be modelled as a simple path with "excursions", where the path wanders to another node, then returns the same way it came, back to the start of the excursion. Now, it is just a matter of finding worthwhile excursions for each node, then summing up all good excursions along the path between each `qu` and `qv` (keeping track of overlaps) along with the simple path.
Hot & Cold|Normal|AC|1|Understand that the sum of distances on a tree follow a simple arithmetic progression. Using tree DP and LCA, we can set the base cases for these progressions, then use them to calculate the actual values.
Dependent Events|Hard|AC|5|Remember the AP statistics principle of `P(A | B)` or "probability of `A` given `B`". We can apply this to the problem by considering the probability of the LCA `x` of `u` and `v` to be the "given" and find `P(u | x)` and `P(v | x)` separately and multiply them together to get the probability that both `u` and `v` happen if `x` happen. Do again for `~x` and sum up their probabilities to get the answer.
Double Tree|Hard|AC|6|Understand that each edge weight can be minimized using Dijkstra's algorithm, then binary lifting can be used like DP to find the minimum distance from a current node to an ancestor in the even or odd tree. Using this, we can find the distance to the even or odd LCA from node `u`, then back down to node `v`, producing an answer.
Functional Contraint|Hard|AC|18|Understand that the function forms a functional graph between the integers modulo `a * b`. Finding the maximal answer if now just a matter of finding LCA on the functional graph.
Graph & Destination|Hard|AC|1|Understand that the problem can be divided into a few basic cases: `r == a || r == b`, `lca(a, b) == a || lca(a, b) == b` and the final case where `a` and `b` are in different subtrees. Each case can be solved easily by testing out different possible paths on paper (even if they weren't, I wouldn't describe them for the sake of brevity).