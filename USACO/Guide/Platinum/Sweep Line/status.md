# Practice Problems Status
Problem|Rating|Correct cases|Attempts|Notes
-|-|-|-|-
Closest Pair|Normal|AC|3|Understand that a set of points within `k` units of the current point along the `x` axis can be kept, where `k` is the current minimum distance between two points. Then, searching in this set on the appropriate range (again, within `k` units) along the `y` axis can be used to find a possible smaller distance `k`. By processing points in increasing order of `x`, each point is inserted to and erased from the set at most once, and there is at most `6` points in the set at any given time (see [https://usaco.guide/plat/sweep-line?lang=cpp](https://usaco.guide/plat/sweep-line?lang=cpp) for details), resulting in a final complexity of `O(N * log2(N))`.
Cow Steeplechase II|Normal|AC|2|Understand that only one intersection needs to be found, since there is guaranteed to be one segment that contains all intersections, meaning all intersections involve the target segment. Upon finding the one intersection, both segments can be checked against all other segments, where the maximum of the two is the target segment. If they both have the same number of intersections, the one with the smaller index is the result, as specified in the problem. To find intersections, sweep line can be used, going through at most `2 * N` segment activation and de-activation events for a final complexity of `O(N * log2(N))`.
Square Overlap|Easy|AC|3|Understand that a set of active horizontal edges can be kept such that for each square, a range of intersecting edges (and with them, squares) can be found using `lower_bound` and `upper_bound`. Then, for each intersection, the overlapping area can be calculated for and applied to the result. Using sweep line, the final complexity is `O(N * log2(N))`
Hill Walk|Normal|AC|2|Understand that a set can keep track of active hills, such that querying the next hill down could be calculated by decrementing the result of `lower_bound` on the current hill. Keeping track of the current hill Bessie is on, as well as updating her hill for every hill event takes `O(N * log2(N))` with sweep line.
2017 - Plahte|Hard|AC|4|Understand that, by only inserting colors into the sets of the innermost sheets, small-to-large merging can then be used to apply these colors to the surrounding "parent" sheets. The final complexity is `O((N + M) * log2(N + M))`.
2006 - Walk|Hard|AC|8|Understand that, because each building is rectangular and cannot touch, the optimal path can simply be found by "falling" onto the next block and "going around it". More specifically, there is never a need to turn around because that would require being backed into a concave corner, and as no rectangular building may touch, concave corners cannot exist. Using sweep line, this can be simulated to find the optimal result.
2020 - Roads|Very Hard|AC|4|Understand that each line "divides" the current sweep line into sections, each of which containing half a convex hull (think monotone chain, but only one half of it). Now it's just a matter of finding the right section for each point, which can be done using a set, then adding it to the convex hull, trying to create edges for each point on the hull using DSU.
2014 - Demarcation|Very Hard|DNF|0|N/A
Grid MST|Normal|DNF|0|N/A
The Sprawl|Hard|DNF|0|N/A
2003 - Seeing the Boundary|Easy|AC|1|Understand that, after sorting the points radially, the points can be processed similar to the typical sweep line. Note that, when halving the domain, a perfect split can't exist since no matter on which axis the division happens, the middle (`y = 0`) must belong to one side or another. To account for this, we can split the domain in a tide-pod-like fashion, where, assuming we divide along the `y`-axis, for `x > 0`, the middle belongs to `y > 0` and for `x < 0`, the middle belongs to `y < 0`. This ensures that, when using cross product to compare two coordinates radially, the `y = 0` case will not cause coordinates `x < 0` and `x > 0` to appear equal.
2006 - Antenna|Easy|AC|8|Understand that, for a radius and a given "center" point (tangent to the surface of the rotating circle), it is easy to determine when a point will enter and exit the circle. Using binary search, we can find the minimum such radius such that at least `k - 1` points are inside the circle at once. Note that my solution is quite slow, and this is because I run a separate binary search for every center. However, it still passes because of an interesting technique I used. I binary search "loosely" to find the parameters of the optimal answer, then "strictly" to get the optimal answer itself. I'm sure it'll come in handy at some point.
Intersection Points|Easy|AC|2|Understand that segment tree with three different types of events: horizontal line activation, horizontal line de-activation and vertical line queries, as well as any range query data structure (Fenwick tree, in this case) is enough to find the number of intersections, yielding the answer.
2018 - Stone|Normal|AC|1|Understand that each move has a contigious range of `PI` length where it contributes non-negatively in a given direction. Using sweep line, we can, for all possible range overlaps, find the one with the greatest magnitude.
2010 - Signaling|Hard|DNF|0|N/A
2017 - Dragon 2|Very Hard|DNF|0|N/A