# Practice Problems Status
Problem|Rating|Correct cases|Attempts|Notes
-|-|-|-|-
Finding a Centroid|Very Easy|AC|1|If an adjacent node's size is greater than half the tree size, the centroid is in its subtree. Following this until there are no more adjacent nodes satisfying such a property leads to the centroid.
Xenia & Tree|Normal|AC|1|Understand that, using centroid decomposition, any path between two nodes can be split by a centroid of a subtree. This allows us to, for each update, for each ancestor centroid, update the minimum distance to a red node. Then, for each query, find the minimum among all ancestor centroids the sum to the centroid as well as the centroid's minimum distance.
Ciel the Commander|Easy|AC|1|By "splitting" the tree down the middle for each rank in decreasing order it ensures that every subsequent split (lesser rank) cannot reach another split of the same rank.
2020 - Village (Maximum)|Easy|AC|2|Understand that splitting the tree down the centroid ensures maximum distance between nodes of any now separated subtree because every path must now go through the centroid. Producing a matching can also be solved greedily as no subtree can be greater than `n / 2` in size, so visiting each subtree entirely in any order, then matching the `i`th and `i + n / 2`th visited nodes suffices.
Fixed-Length Paths I|Easy|AC|2|Understand that solving for each path of length `k` that passes through the centroid at each decomposition yields the answer as no paths overlap once the centroid is removed from the tree.
Fixed-Length Paths II|Easy|AC|2|Similar to the previous version of the problem, just using a segment tree to query for ranges of values that satisfy a distance sum between `k1` and `k2`.
Yin and Yang|Easy|AC|1|Understand that any tuple `a`, `b` and `c` such that the difference between the number of Charcolais and Angus cows between `a` and `b` and `b` and `c` are both `0` is a valid path. With this, we can find the difference, starting at the centroid, for each node and use combinatorics to find valid tuples by matching values.
2011 - Race|Normal|AC|2|Solve for all possible minimal paths passing through the centroid with length `k` using maps.
New Barns|Normal|AC|2|Understand that a path crossing a certain node `a` can be made from any two nodes connecting to `a` as long as they are part of different subtrees. Using centroid decomposition, we can assign, for each neighbor `b` of the centroid `a`, a maximum distance achievable to `a` from the subtree of `b`. Now, each query is just a matter of updating that per build query and referencing the current state for the output queries.
Sherlock's bet to Moriarty|Normal|8|AC|Understand that the regions can be constructed by flattening the polygon (think "unrolling") and layering edges on top of each other. It's best explained visually, so I won't bother explaining it here; try it for yourself. Following this logic, we can also sort the regions by increasing order of their upper bound and lower bound in this order of significance. Finally, labelling the regions can be solved using centroid decomposition as each path going through the current centroid can be guaranteed to satisfy the given property by labelling the centroid a lower value than every node passing through it.
Digit Tree|Normal|AC|5|Understand that, any value that equals `0` modulo `m` will remain equal to `0` regardless of any value multiplied to it. With this, we can have a "lower" path that decreases in significance (by a factor of `10`) with depth and an "upper" path that increases in significance. Using centroid decomposition, we can find all combinations of lower and upper paths that sum to `0`. On a side note, both binary exponentiation and Euclidian division did not seem to provide accurate modular inverses despite (as I see it) the conditions for both being met. In the end, the Extended Euclidian algorithm yielded correct modular inverses.
Double Tree|Normal|AC|4|Similarly to the solution to the same problem under binary lifting, Dijkstra's was used to optimize each edge. Afterwards, centroid decomposition was used to solve each query offline.
2014 - Factories|Normal|AC|2|Similar to "Xenia & Tree", just undoing red nodes at the end of each query.
2019 - Lampice|Normal|DNF|0|N/A
Bob Equilibrium|Hard|AC|3|Similar to "Fixed-Length Paths II". Find the maximum "radius" to a given customer such that, if Bob places a shop within this radius, he will gain said customer. Now, for each node, find the number of paths to a given endpoint `a` where the distance is at most `a`'s radius.
Time Traveller Imaxblue|Hard|DNF|0|N/A
2013 - Synchronization|Hard|DNF|0|N/A
Cow At Large|Very Hard|DNF|0|N/A