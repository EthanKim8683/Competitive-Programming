# Practice Problems Status
Problem|Rating|Correct cases|Attempts|Notes
-|-|-|-|-
Path Queries II|Easy|AC|1|N/A
Query on a tree again!|Easy|AC|1|Understand that HLD for minimum black node index solves the problem easily.
Subtree & Paths|Normal|AC|1|Understand that HLD with range update and range query can be used alongside Euler tour to allow for subtree updates and path queries.
Grass Planting|Normal|AC|1|Understand that each edge has a "bottom" node that could be used, in the case of HLD, as the index of its data in the segment tree.
Vertex Set Path Composite|Normal|AC|1|Understand that a non-commutative combiner function must be used, and thus, LCA can be used to separate the different directions of segment tree queries.
Tree Queries|Hard|AC|1|Understand that every first-type operation given node `v` splits the tree into `k` segments, for each of the `k` nodes adjacent to node `v`. This is because the subtrees of each adjacent node each can pair with any node from any other subtree because their paths would require visiting `v`, resulting in an addition of `d * (n - sizs[i]) / n` to each neighbor `i`'s expected value. Doing this naively, however, could result in at worst `O(N * Q)` (at most `N - 1` neighbors per node), and so, HLD with a non-commutative segment tree can be used. More specifically, each segment keeps track of the "value" of the lowest point of the segment and the index of the node on the highest point of the segment. Now, when combining, the value of the lowest point of the parent segment can be multiplied with the size of the subtree of the highest point of the child segment to produce the size of the subtree multiplied by the value *without* `O(N)` updates. With an additional segment tree handling the parent subtrees, the problem can be solved easily.
The Tree|Hard|AC|1|Understand that HLD with a lazy-propogated non-commutative combiner function segment tree for paths to root suffices.
Tree Game|Hard|AC|1|Understand that HLD with a lazy-propogated segment tree for paths to root can be used to handle the inversion updates. For queries, note that each node has at most one heavy edge, while the rest are light edges. Using this, we can update at each light edge the current subtree white-sum of a child to its parent while handling the final heavy edge's subtree white-sum in each query. Once all the white-sums are found, combinatorics takes care of the rest.
2013 - Synchronization|Hard|AC|1|Understand that subtree sizes and component parents can be kept track with using segment trees and HLD with queries to root. More specficially, each node that is part of a component contributes in a manner affecting all of its ancestors. Combined with a maximizing segment tree to find the component parent, this can find the "size" of each component. With this, it is easy to make updates and solve for the number of unique pieces of information per component using PIE.
2018 - Cats or Dogs|Very Hard|DNF|0|N/A